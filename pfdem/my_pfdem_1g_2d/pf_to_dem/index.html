<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>User API documentation</title>
<meta name="description" content="@author: Alexandre Sac--Morane
alexandre.sac-morane@enpc.fr â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pf_to_dem</code></h1>
</header>
<section id="section-intro">
<p>@author: Alexandre Sac&ndash;Morane
alexandre.sac-morane@enpc.fr</p>
<p>This is the file used to transmit data between phase field and dem.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">
  # -*- encoding=utf-8 -*-

  import pickle, math, os, shutil
  from pathlib import Path
  import numpy as np
  import matplotlib.pyplot as plt
  import vtk
  from vtk.util.numpy_support import vtk_to_numpy

  # own
  import tools

  # -----------------------------------------------------------------------------#

  def index_to_str(j):
      '''
      Convert a integer into a string with the format XXX.
      '''
      if j < 10:
          return '00'+str(j)
      elif 10<=j and j < 100:
          return '0'+str(j)
      else :
          return str(j)

  # -----------------------------------------------------------------------------#

  def read_vtk(dict_user, dict_sample, j_str):
      '''
      Read the last vtk files to obtain data from MOOSE.

      Do not work calling yade.
      '''
      eta_1_map_old = dict_sample['eta_1_map'].copy()
      c_map_old = dict_sample['c_map'].copy()
      L_eta1 = []
      L_c = []
      if not dict_sample['Map_known']:
          L_limits = []
          L_XYZ = []
          L_L_i_XYZ_used = []
      else :
          L_XYZ = dict_sample['L_XYZ']

      # iterate on the proccessors used
      for i_proc in range(dict_user['n_proc']):

          # name of the file to load
          namefile = 'vtk/pf_other_'+j_str+'_'+str(i_proc)+'.vtu'

          # load a vtk file as input
          reader = vtk.vtkXMLUnstructuredGridReader()
          reader.SetFileName(namefile)
          reader.Update()

          # Grab a scalar from the vtk file
          nodes_vtk_array = reader.GetOutput().GetPoints().GetData()
          eta1_vtk_array = reader.GetOutput().GetPointData().GetArray("eta1")
          c_vtk_array = reader.GetOutput().GetPointData().GetArray("c")

          #Get the coordinates of the nodes and the scalar values
          nodes_array = vtk_to_numpy(nodes_vtk_array)
          eta1_array = vtk_to_numpy(eta1_vtk_array)
          c_array = vtk_to_numpy(c_vtk_array)

          # map is not know
          if not dict_sample['Map_known']:
              # look for limits
              x_min = None
              x_max = None
              y_min = None
              y_max = None
              # save the map
              L_i_XYZ_used = []
              # Must detect common zones between processors
              for i_XYZ in range(len(nodes_array)) :
                  XYZ = nodes_array[i_XYZ]
                  # Do not consider twice a point
                  if list(XYZ) not in L_XYZ :
                      L_XYZ.append(list(XYZ))
                      L_eta1.append(eta1_array[i_XYZ])
                      L_c.append(c_array[i_XYZ])
                      L_i_XYZ_used.append(i_XYZ)
                      # set first point
                      if x_min == None :
                          x_min = list(XYZ)[0]
                          x_max = list(XYZ)[0]
                          y_min = list(XYZ)[1]
                          y_max = list(XYZ)[1]
                      # look for limits of the processor
                      else :
                          if list(XYZ)[0] < x_min:
                              x_min = list(XYZ)[0]
                          if list(XYZ)[0] > x_max:
                              x_max = list(XYZ)[0]
                          if list(XYZ)[1] < y_min:
                              y_min = list(XYZ)[1]
                          if list(XYZ)[1] > y_max:
                              y_max = list(XYZ)[1]
              # Here the algorithm can be help as the mapping is known
              L_L_i_XYZ_used.append(L_i_XYZ_used)
              # save limits
              L_limits.append([x_min,x_max,y_min,y_max])

          # map is known
          else :
              # the last term considered is at the end of the list
              if dict_sample['L_L_i_XYZ_used'][i_proc][-1] == len(nodes_array)-1:
                  L_eta1 = list(L_eta1) + list(eta1_array)
                  L_c = list(L_c) + list(c_array)
              # the last term considered is not at the end of the list
              else :
                  L_eta1 = list(L_eta1) + list(eta1_array[dict_sample['L_L_i_XYZ_used'][i_proc][0]: dict_sample['L_L_i_XYZ_used'][i_proc][-1]+1])
                  L_c = list(L_c) + list(c_array[dict_sample['L_L_i_XYZ_used'][i_proc][0]: dict_sample['L_L_i_XYZ_used'][i_proc][-1]+1])

      if not dict_sample['Map_known']:
          # plot processors distribution
          if 'processor' in dict_user['L_figures'] and not dict_user['remesh']:
              fig, (ax1) = plt.subplots(1,1,figsize=(16,9))
              # parameters
              title_fontsize = 20
              for i_proc in range(len(L_limits)):
                  limits = L_limits[i_proc]
                  ax1.plot([limits[0],limits[1],limits[1],limits[0],limits[0]],[limits[2],limits[2],limits[3],limits[3],limits[2]], label='proc '+str(i_proc))
              ax1.legend()
              ax1.set_xlabel('X (m)')
              ax1.set_ylabel('Y (m)')
              ax1.set_title('Processor i has the priority on i+1',fontsize = title_fontsize)
              fig.suptitle('Processors ditribution',fontsize = 1.2*title_fontsize)
              fig.tight_layout()
              fig.savefig('plot/processors_distribution.png')
              plt.close(fig)
          # the map is known
          dict_sample['Map_known'] = True
          dict_sample['L_L_i_XYZ_used'] = L_L_i_XYZ_used
          dict_sample['L_XYZ'] = L_XYZ

      # rebuild map from lists
      for i_XYZ in range(len(L_XYZ)):
          # find nearest node
          L_search = list(abs(np.array(dict_sample['x_L']-L_XYZ[i_XYZ][0])))
          i_x = L_search.index(min(L_search))
          L_search = list(abs(np.array(dict_sample['y_L']-L_XYZ[i_XYZ][1])))
          i_y = L_search.index(min(L_search))
          # rewrite map
          dict_sample['eta_1_map'][-1-i_y, i_x] = L_eta1[i_XYZ]
          dict_sample['c_map'][-1-i_y, i_x] = L_c[i_XYZ]

  # -----------------------------------------------------------------------------#

  def compute_vertices(dict_user, dict_sample):
      '''
      From a phase map, compute vertices coordinates for polyhedral.
      '''
      # compute vertices for grain
      L_vertices_1 = interpolate_vertices(dict_sample['eta_1_map'], dict_sample['pos_1'], dict_user, dict_sample)

      # compute vertices for plate
      L_vertices_2 = ((min(dict_sample['x_L']), 0, 0,),
                      (max(dict_sample['x_L']), 0, 0,),
                      (max(dict_sample['x_L']), min(dict_sample['y_L']), 0,),
                      (min(dict_sample['x_L']), min(dict_sample['y_L']), 0,),
                      (min(dict_sample['x_L']), 0, 1,),
                      (max(dict_sample['x_L']), 0, 1,),
                      (max(dict_sample['x_L']), min(dict_sample['y_L']), 1,),
                      (min(dict_sample['x_L']), min(dict_sample['y_L']), 1,))

      # save data
      dict_save = {
      'L_vertices_1': L_vertices_1,
      'L_vertices_2': L_vertices_2
      }
      with open('data/planes.data', 'wb') as handle:
          pickle.dump(dict_save, handle, protocol=pickle.HIGHEST_PROTOCOL)

      # compute sample height and vertical strain
      L_x_1, L_y_1 = tools.tuplet_to_list(L_vertices_1) # from tools.py
      sample_height = max(L_y_1)
      dict_user['L_sample_height'].append(sample_height)

      # compute sphericities
      AreaSphericity, DiameterSphericity, CircleRatioSphericity, PerimeterSphericity, WidthToLengthRatioSpericity = tools.compute_sphericities(L_vertices_1) # from tools.py
      # save and plot
      dict_user['L_AreaSphericity'].append(AreaSphericity)
      dict_user['L_DiameterSphericity'].append(DiameterSphericity)
      dict_user['L_CircleRatioSphericity'].append(CircleRatioSphericity)
      dict_user['L_PerimeterSphericity'].append(PerimeterSphericity)
      dict_user['L_WidthToLengthRatioSpericity'].append(WidthToLengthRatioSpericity)

      if 'sphericities' in dict_user['L_figures']:
          fig, (ax1) = plt.subplots(1,1,figsize=(16,9))
          ax1.plot(dict_user['L_AreaSphericity'], label='Area sphericity')
          ax1.plot(dict_user['L_DiameterSphericity'], label='Diameter sphericity')
          ax1.plot(dict_user['L_CircleRatioSphericity'], label='Circle ratio sphericity')
          ax1.plot(dict_user['L_PerimeterSphericity'], label='Perimeter sphericity')
          ax1.plot(dict_user['L_WidthToLengthRatioSpericity'], label='Width/Length spericity')
          ax1.legend()
          plt.suptitle('Grain sphericities (G1)', fontsize=20)
          fig.tight_layout()
          fig.savefig('plot/sphericities.png')
          plt.close(fig)


  # -----------------------------------------------------------------------------#

  def interpolate_vertices(eta_i_map, center, dict_user, dict_sample):
      '''
      Interpolate vertices for polyhedral.
      '''
      map_phi = []
      L_phi = []
      for i_phi in range(dict_user['n_phi']):
          phi = 2*math.pi*i_phi/dict_user['n_phi']
          L_phi.append(phi)
          map_phi.append([])
      L_phi.append(2*math.pi)
      for i_x in range(len(dict_sample['x_L'])-1):
          for i_y in range(len(dict_sample['y_L'])-1):
              L_in = [] # list the nodes inside the grain
              if eta_i_map[-1-i_y    , i_x] > 0.5 :
                  L_in.append(0)
              if eta_i_map[-1-(i_y+1), i_x] > 0.5 :
                  L_in.append(1)
              if eta_i_map[-1-(i_y+1), i_x+1] > 0.5 :
                  L_in.append(2)
              if eta_i_map[-1-i_y    , i_x+1] > 0.5 :
                  L_in.append(3)
              if L_in != [] and L_in != [0,1,2,3]:
                  center_mesh = (np.array([dict_sample['x_L'][i_x], dict_sample['y_L'][i_y]])+np.array([dict_sample['x_L'][i_x+1], dict_sample['y_L'][i_y+1]]))/2
                  u = (center_mesh-np.array(center))/np.linalg.norm(center_mesh-np.array(center))
                  # compute phi
                  if u[1]>=0:
                      phi = math.acos(u[0])
                  else :
                      phi = 2*math.pi-math.acos(u[0])
                  # iterate on the lines of the mesh to find the plane intersection
                  L_p = []
                  if (0 in L_in and 1 not in L_in) or (0 not in L_in and 1 in L_in):# line 01
                      x_p = dict_sample['x_L'][i_x]
                      y_p = (0.5-eta_i_map[-1-i_y, i_x])/(eta_i_map[-1-(i_y+1), i_x]-eta_i_map[-1-i_y, i_x])*(dict_sample['y_L'][i_y+1]-dict_sample['y_L'][i_y])+dict_sample['y_L'][i_y]
                      L_p.append(np.array([x_p, y_p]))
                  if (1 in L_in and 2 not in L_in) or (1 not in L_in and 2 in L_in):# line 12
                      x_p = (0.5-eta_i_map[-1-(i_y+1), i_x])/(eta_i_map[-1-(i_y+1), i_x+1]-eta_i_map[-1-(i_y+1), i_x])*(dict_sample['x_L'][i_x+1]-dict_sample['x_L'][i_x])+dict_sample['x_L'][i_x]
                      y_p = dict_sample['y_L'][i_y+1]
                      L_p.append(np.array([x_p, y_p]))
                  if (2 in L_in and 3 not in L_in) or (2 not in L_in and 3 in L_in):# line 23
                      x_p = dict_sample['x_L'][i_x+1]
                      y_p = (0.5-eta_i_map[-1-i_y, i_x+1])/(eta_i_map[-1-(i_y+1), i_x+1]-eta_i_map[-1-i_y, i_x+1])*(dict_sample['y_L'][i_y+1]-dict_sample['y_L'][i_y])+dict_sample['y_L'][i_y]
                      L_p.append(np.array([x_p, y_p]))
                  if (3 in L_in and 0 not in L_in) or (3 not in L_in and 0 in L_in):# line 30
                      x_p = (0.5-eta_i_map[-1-i_y, i_x])/(eta_i_map[-1-i_y, i_x+1]-eta_i_map[-1-i_y, i_x])*(dict_sample['x_L'][i_x+1]-dict_sample['x_L'][i_x])+dict_sample['x_L'][i_x]
                      y_p = dict_sample['y_L'][i_y]
                      L_p.append(np.array([x_p, y_p]))
                  # compute the mean point
                  p_mean = np.array([0,0])
                  for p in L_p :
                      p_mean = p_mean + p
                  p_mean = p_mean/len(L_p)
                  # look phi in L_phi
                  i_phi = 0
                  while not (L_phi[i_phi] <= phi and phi <= L_phi[i_phi+1]) :
                      i_phi = i_phi + 1
                  # save p_mean in the map
                  map_phi[i_phi].append(p_mean)

      L_vertices = ()
      # interpolate plane (Least squares method)
      for i_phi in range(len(map_phi)):
          if map_phi[i_phi] != []:
              # mean vertices
              mean_v = np.array([0, 0])
              for v_i in map_phi[i_phi]:
                  mean_v = mean_v + v_i/len(map_phi[i_phi])
              # save
              L_vertices = L_vertices + ((mean_v[0], mean_v[1], 0,),)
              L_vertices = L_vertices + ((mean_v[0], mean_v[1], 1),)

      return L_vertices

  # -----------------------------------------------------------------------------#

  def control_force(dict_user, dict_sample):
      '''
      Control force applied in DEM with the contact volume.

      Because of the fact that convvex shape is not possible in Yade.
      '''
      # determine the volume contact in Moose (etai ad j > 0.5)
      V_contact_moose = 0
      for i_x in range(len(dict_sample['x_L'])):
          for i_y in range(len(dict_sample['y_L'])):
              if dict_sample['eta_1_map'][-1-i_y, i_x] > 0.5 and dict_sample['y_L'][i_y]<=0:
                  V_contact_moose = V_contact_moose + (dict_sample['x_L'][1]-dict_sample['x_L'][0])*(dict_sample['y_L'][1]-dict_sample['y_L'][0])*1

      # compare with the volume contact expected
      # in Yade, F=k*V and 1/k = 1/Y1 + 1/Y2
      V_expected = 2*dict_user['force_applied_target']/dict_user['E']
      # the comparison is important if multiple controls are done per one PFDEM iteration
      # if only only control is done, the adaptation of the force can be done always
      #if V_contact_moose < (1-dict_user['steady_state_detection'])*V_expected or (1+dict_user['steady_state_detection'])*V_expected < V_contact_moose:
      if True:
          # control the force applied
          dict_user['force_applied'] = dict_user['force_applied']*V_expected/V_contact_moose

      # save and plot
      dict_user['L_force_applied'].append(dict_user['force_applied'])
      if 'force_applied' in dict_user['L_figures']:
          fig, (ax1) = plt.subplots(1,1,figsize=(16,9))
          ax1.plot(dict_user['L_force_applied'])
          plt.suptitle('Force applied in Yade (DEM)', fontsize=20)
          fig.tight_layout()
          fig.savefig('plot/force_applied.png')
          plt.close(fig)
</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>

<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pf_to_dem.index_to_str"><code class="name flex">
<span>def <span class="ident">index_to_str</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p> Convert a integer into a string with the format XXX.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">
  def index_to_str(j):
      '''
      Convert a integer into a string with the format XXX.
      '''
      if j < 10:
          return '00'+str(j)
      elif 10<=j and j< 100:
          return '0'+str(j)
      else :
          return str(j)
</code></pre>
</details>
</dd>

<dt id="pf_to_dem.read_vtk"><code class="name flex">
<span>def <span class="ident">read_vtk</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p> Read the last vtk files to obtain data from MOOSE.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">
  def read_vtk(dict_user, dict_sample, j_str):
      '''
      Read the last vtk files to obtain data from MOOSE.

      Do not work calling yade.
      '''
      eta_1_map_old = dict_sample['eta_1_map'].copy()
      c_map_old = dict_sample['c_map'].copy()
      L_eta1 = []
      L_c = []
      if not dict_sample['Map_known']:
          L_limits = []
          L_XYZ = []
          L_L_i_XYZ_used = []
      else :
          L_XYZ = dict_sample['L_XYZ']

      # iterate on the proccessors used
      for i_proc in range(dict_user['n_proc']):

          # name of the file to load
          namefile = 'vtk/pf_other_'+j_str+'_'+str(i_proc)+'.vtu'

          # load a vtk file as input
          reader = vtk.vtkXMLUnstructuredGridReader()
          reader.SetFileName(namefile)
          reader.Update()

          # Grab a scalar from the vtk file
          nodes_vtk_array = reader.GetOutput().GetPoints().GetData()
          eta1_vtk_array = reader.GetOutput().GetPointData().GetArray("eta1")
          c_vtk_array = reader.GetOutput().GetPointData().GetArray("c")

          #Get the coordinates of the nodes and the scalar values
          nodes_array = vtk_to_numpy(nodes_vtk_array)
          eta1_array = vtk_to_numpy(eta1_vtk_array)
          c_array = vtk_to_numpy(c_vtk_array)

          # map is not know
          if not dict_sample['Map_known']:
              # look for limits
              x_min = None
              x_max = None
              y_min = None
              y_max = None
              # save the map
              L_i_XYZ_used = []
              # Must detect common zones between processors
              for i_XYZ in range(len(nodes_array)) :
                  XYZ = nodes_array[i_XYZ]
                  # Do not consider twice a point
                  if list(XYZ) not in L_XYZ :
                      L_XYZ.append(list(XYZ))
                      L_eta1.append(eta1_array[i_XYZ])
                      L_c.append(c_array[i_XYZ])
                      L_i_XYZ_used.append(i_XYZ)
                      # set first point
                      if x_min == None :
                          x_min = list(XYZ)[0]
                          x_max = list(XYZ)[0]
                          y_min = list(XYZ)[1]
                          y_max = list(XYZ)[1]
                      # look for limits of the processor
                      else :
                          if list(XYZ)[0] < x_min:
                              x_min = list(XYZ)[0]
                          if list(XYZ)[0] > x_max:
                              x_max = list(XYZ)[0]
                          if list(XYZ)[1] < y_min:
                              y_min = list(XYZ)[1]
                          if list(XYZ)[1] > y_max:
                              y_max = list(XYZ)[1]
              # Here the algorithm can be help as the mapping is known
              L_L_i_XYZ_used.append(L_i_XYZ_used)
              # save limits
              L_limits.append([x_min,x_max,y_min,y_max])

          # map is known
          else :
              # the last term considered is at the end of the list
              if dict_sample['L_L_i_XYZ_used'][i_proc][-1] == len(nodes_array)-1:
                  L_eta1 = list(L_eta1) + list(eta1_array)
                  L_c = list(L_c) + list(c_array)
              # the last term considered is not at the end of the list
              else :
                  L_eta1 = list(L_eta1) + list(eta1_array[dict_sample['L_L_i_XYZ_used'][i_proc][0]: dict_sample['L_L_i_XYZ_used'][i_proc][-1]+1])
                  L_c = list(L_c) + list(c_array[dict_sample['L_L_i_XYZ_used'][i_proc][0]: dict_sample['L_L_i_XYZ_used'][i_proc][-1]+1])

      if not dict_sample['Map_known']:
          # plot processors distribution
          if 'processor' in dict_user['L_figures'] and not dict_user['remesh']:
              fig, (ax1) = plt.subplots(1,1,figsize=(16,9))
              # parameters
              title_fontsize = 20
              for i_proc in range(len(L_limits)):
                  limits = L_limits[i_proc]
                  ax1.plot([limits[0],limits[1],limits[1],limits[0],limits[0]],[limits[2],limits[2],limits[3],limits[3],limits[2]], label='proc '+str(i_proc))
              ax1.legend()
              ax1.set_xlabel('X (m)')
              ax1.set_ylabel('Y (m)')
              ax1.set_title('Processor i has the priority on i+1',fontsize = title_fontsize)
              fig.suptitle('Processors ditribution',fontsize = 1.2*title_fontsize)
              fig.tight_layout()
              fig.savefig('plot/processors_distribution.png')
              plt.close(fig)
          # the map is known
          dict_sample['Map_known'] = True
          dict_sample['L_L_i_XYZ_used'] = L_L_i_XYZ_used
          dict_sample['L_XYZ'] = L_XYZ

      # rebuild map from lists
      for i_XYZ in range(len(L_XYZ)):
          # find nearest node
          L_search = list(abs(np.array(dict_sample['x_L']-L_XYZ[i_XYZ][0])))
          i_x = L_search.index(min(L_search))
          L_search = list(abs(np.array(dict_sample['y_L']-L_XYZ[i_XYZ][1])))
          i_y = L_search.index(min(L_search))
          # rewrite map
          dict_sample['eta_1_map'][-1-i_y, i_x] = L_eta1[i_XYZ]
          dict_sample['c_map'][-1-i_y, i_x] = L_c[i_XYZ]
</code></pre>
</details>
</dd>

<dt id="pf_to_dem.compute_vertices"><code class="name flex">
<span>def <span class="ident">compute_vertices</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p> From a phase map, compute vertices coordinates for polyhedral.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">
  def compute_vertices(dict_user, dict_sample):
      '''
      From a phase map, compute vertices coordinates for polyhedral.
      '''
      # compute vertices for grain
      L_vertices_1 = interpolate_vertices(dict_sample['eta_1_map'], dict_sample['pos_1'], dict_user, dict_sample)

      # compute vertices for plate
      L_vertices_2 = ((min(dict_sample['x_L']), 0, 0,),
                      (max(dict_sample['x_L']), 0, 0,),
                      (max(dict_sample['x_L']), min(dict_sample['y_L']), 0,),
                      (min(dict_sample['x_L']), min(dict_sample['y_L']), 0,),
                      (min(dict_sample['x_L']), 0, 1,),
                      (max(dict_sample['x_L']), 0, 1,),
                      (max(dict_sample['x_L']), min(dict_sample['y_L']), 1,),
                      (min(dict_sample['x_L']), min(dict_sample['y_L']), 1,))

      # save data
      dict_save = {
      'L_vertices_1': L_vertices_1,
      'L_vertices_2': L_vertices_2
      }
      with open('data/planes.data', 'wb') as handle:
          pickle.dump(dict_save, handle, protocol=pickle.HIGHEST_PROTOCOL)

      # compute sample height and vertical strain
      L_x_1, L_y_1 = tools.tuplet_to_list(L_vertices_1) # from tools.py
      sample_height = max(L_y_1)
      dict_user['L_sample_height'].append(sample_height)

      # compute sphericities
      AreaSphericity, DiameterSphericity, CircleRatioSphericity, PerimeterSphericity, WidthToLengthRatioSpericity = tools.compute_sphericities(L_vertices_1) # from tools.py
      # save and plot
      dict_user['L_AreaSphericity'].append(AreaSphericity)
      dict_user['L_DiameterSphericity'].append(DiameterSphericity)
      dict_user['L_CircleRatioSphericity'].append(CircleRatioSphericity)
      dict_user['L_PerimeterSphericity'].append(PerimeterSphericity)
      dict_user['L_WidthToLengthRatioSpericity'].append(WidthToLengthRatioSpericity)

      if 'sphericities' in dict_user['L_figures']:
          fig, (ax1) = plt.subplots(1,1,figsize=(16,9))
          ax1.plot(dict_user['L_AreaSphericity'], label='Area sphericity')
          ax1.plot(dict_user['L_DiameterSphericity'], label='Diameter sphericity')
          ax1.plot(dict_user['L_CircleRatioSphericity'], label='Circle ratio sphericity')
          ax1.plot(dict_user['L_PerimeterSphericity'], label='Perimeter sphericity')
          ax1.plot(dict_user['L_WidthToLengthRatioSpericity'], label='Width/Length spericity')
          ax1.legend()
          plt.suptitle('Grain sphericities (G1)', fontsize=20)
          fig.tight_layout()
          fig.savefig('plot/sphericities.png')
          plt.close(fig)
</code></pre>
</details>
</dd>

<dt id="pf_to_dem.interpolate_vertices"><code class="name flex">
<span>def <span class="ident">interpolate_vertices</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p> Interpolate vertices for polyhedral.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">
  def interpolate_vertices(eta_i_map, center, dict_user, dict_sample):
      '''
      Interpolate vertices for polyhedral.
      '''
      map_phi = []
      L_phi = []
      for i_phi in range(dict_user['n_phi']):
          phi = 2*math.pi*i_phi/dict_user['n_phi']
          L_phi.append(phi)
          map_phi.append([])
      L_phi.append(2*math.pi)
      for i_x in range(len(dict_sample['x_L'])-1):
          for i_y in range(len(dict_sample['y_L'])-1):
              L_in = [] # list the nodes inside the grain
              if eta_i_map[-1-i_y    , i_x] > 0.5 :
                  L_in.append(0)
              if eta_i_map[-1-(i_y+1), i_x] > 0.5 :
                  L_in.append(1)
              if eta_i_map[-1-(i_y+1), i_x+1] > 0.5 :
                  L_in.append(2)
              if eta_i_map[-1-i_y    , i_x+1] > 0.5 :
                  L_in.append(3)
              if L_in != [] and L_in != [0,1,2,3]:
                  center_mesh = (np.array([dict_sample['x_L'][i_x], dict_sample['y_L'][i_y]])+np.array([dict_sample['x_L'][i_x+1], dict_sample['y_L'][i_y+1]]))/2
                  u = (center_mesh-np.array(center))/np.linalg.norm(center_mesh-np.array(center))
                  # compute phi
                  if u[1]>=0:
                      phi = math.acos(u[0])
                  else :
                      phi = 2*math.pi-math.acos(u[0])
                  # iterate on the lines of the mesh to find the plane intersection
                  L_p = []
                  if (0 in L_in and 1 not in L_in) or (0 not in L_in and 1 in L_in):# line 01
                      x_p = dict_sample['x_L'][i_x]
                      y_p = (0.5-eta_i_map[-1-i_y, i_x])/(eta_i_map[-1-(i_y+1), i_x]-eta_i_map[-1-i_y, i_x])*(dict_sample['y_L'][i_y+1]-dict_sample['y_L'][i_y])+dict_sample['y_L'][i_y]
                      L_p.append(np.array([x_p, y_p]))
                  if (1 in L_in and 2 not in L_in) or (1 not in L_in and 2 in L_in):# line 12
                      x_p = (0.5-eta_i_map[-1-(i_y+1), i_x])/(eta_i_map[-1-(i_y+1), i_x+1]-eta_i_map[-1-(i_y+1), i_x])*(dict_sample['x_L'][i_x+1]-dict_sample['x_L'][i_x])+dict_sample['x_L'][i_x]
                      y_p = dict_sample['y_L'][i_y+1]
                      L_p.append(np.array([x_p, y_p]))
                  if (2 in L_in and 3 not in L_in) or (2 not in L_in and 3 in L_in):# line 23
                      x_p = dict_sample['x_L'][i_x+1]
                      y_p = (0.5-eta_i_map[-1-i_y, i_x+1])/(eta_i_map[-1-(i_y+1), i_x+1]-eta_i_map[-1-i_y, i_x+1])*(dict_sample['y_L'][i_y+1]-dict_sample['y_L'][i_y])+dict_sample['y_L'][i_y]
                      L_p.append(np.array([x_p, y_p]))
                  if (3 in L_in and 0 not in L_in) or (3 not in L_in and 0 in L_in):# line 30
                      x_p = (0.5-eta_i_map[-1-i_y, i_x])/(eta_i_map[-1-i_y, i_x+1]-eta_i_map[-1-i_y, i_x])*(dict_sample['x_L'][i_x+1]-dict_sample['x_L'][i_x])+dict_sample['x_L'][i_x]
                      y_p = dict_sample['y_L'][i_y]
                      L_p.append(np.array([x_p, y_p]))
                  # compute the mean point
                  p_mean = np.array([0,0])
                  for p in L_p :
                      p_mean = p_mean + p
                  p_mean = p_mean/len(L_p)
                  # look phi in L_phi
                  i_phi = 0
                  while not (L_phi[i_phi] <= phi and phi <= L_phi[i_phi+1]) :
                      i_phi = i_phi + 1
                  # save p_mean in the map
                  map_phi[i_phi].append(p_mean)

      L_vertices = ()
      # interpolate plane (Least squares method)
      for i_phi in range(len(map_phi)):
          if map_phi[i_phi] != []:
              # mean vertices
              mean_v = np.array([0, 0])
              for v_i in map_phi[i_phi]:
                  mean_v = mean_v + v_i/len(map_phi[i_phi])
              # save
              L_vertices = L_vertices + ((mean_v[0], mean_v[1], 0,),)
              L_vertices = L_vertices + ((mean_v[0], mean_v[1], 1),)

      return L_vertices
</code></pre>
</details>
</dd>

<dt id="pf_to_dem.control_force"><code class="name flex">
<span>def <span class="ident">control_force</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p> Control force applied in DEM with the contact volume.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">
  def control_force(dict_user, dict_sample):
      '''
      Control force applied in DEM with the contact volume.

      Because of the fact that convvex shape is not possible in Yade.
      '''
      # determine the volume contact in Moose (etai ad j > 0.5)
      V_contact_moose = 0
      for i_x in range(len(dict_sample['x_L'])):
          for i_y in range(len(dict_sample['y_L'])):
              if dict_sample['eta_1_map'][-1-i_y, i_x] > 0.5 and dict_sample['y_L'][i_y]<=0:
                  V_contact_moose = V_contact_moose + (dict_sample['x_L'][1]-dict_sample['x_L'][0])*(dict_sample['y_L'][1]-dict_sample['y_L'][0])*1

      # compare with the volume contact expected
      # in Yade, F=k*V and 1/k = 1/Y1 + 1/Y2
      V_expected = 2*dict_user['force_applied_target']/dict_user['E']
      # the comparison is important if multiple controls are done per one PFDEM iteration
      # if only only control is done, the adaptation of the force can be done always
      #if V_contact_moose < (1-dict_user['steady_state_detection'])*V_expected or (1+dict_user['steady_state_detection'])*V_expected < V_contact_moose:
      if True:
          # control the force applied
          dict_user['force_applied'] = dict_user['force_applied']*V_expected/V_contact_moose

      # save and plot
      dict_user['L_force_applied'].append(dict_user['force_applied'])
      if 'force_applied' in dict_user['L_figures']:
          fig, (ax1) = plt.subplots(1,1,figsize=(16,9))
          ax1.plot(dict_user['L_force_applied'])
          plt.suptitle('Force applied in Yade (DEM)', fontsize=20)
          fig.tight_layout()
          fig.savefig('plot/force_applied.png')
          plt.close(fig)
</code></pre>
</details>
</dd>

</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pf_to_dem.index_to_str" href="#pf_to_dem.index_to_str">index_to_str</a></code></li>
<li><code><a title="pf_to_dem.read_vtk" href="#pf_to_dem.read_vtk">read_vtk</a></code></li>
<li><code><a title="pf_to_dem.compute_vertices" href="#pf_to_dem.compute_vertices">compute_vertices</a></code></li>
<li><code><a title="pf_to_dem.interpolate_vertices" href="#pf_to_dem.interpolate_vertices">interpolate_vertices</a></code></li>
<li><code><a title="pf_to_dem.control_force" href="#pf_to_dem.control_force">control_force</a></code></li>
</ul>
</li>
</ul>
<br>
<a href="https://alexsacmorane.github.io/pfdem/my_pfdem_1g_2d">MY_PFDEM_1G_2D</a>
<br>
<a href="https://alexsacmorane.github.io/pfdem">PFDEM</a>
<br>
<a href="https://alexsacmorane.github.io">Home</a>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
