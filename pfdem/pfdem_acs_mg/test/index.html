<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>test API documentation</title>
<meta name="description" content="@author: Alexandre Sac--Morane
alexandre.sac-morane@enpc.fr â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>test</code></h1>
</header>
<section id="section-intro">
<p>@author: Alexandre Sac&ndash;Morane
alexandre.sac-morane@enpc.fr</p>
<p>This is the test file to verify if the code is running well.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
@author: Alexandre Sac--Morane
alexandre.sac-morane@enpc.fr

This is the test file to verify if the code is running well.
&#34;&#34;&#34;

#-------------------------------------------------------------------------------
#Librairy
#-------------------------------------------------------------------------------

from pathlib import Path
from datetime import datetime
import numpy as np
import matplotlib.pyplot as plt
import unittest
import os
import shutil
import math

#own functions and classes
import User
import Owntools
import Owntools.Compute
import Owntools.Plot
import Owntools.Write
import Grain
import Report
from main import iteration_main_until_pf, iteration_main_from_pf

#-------------------------------------------------------------------------------
#Test
#-------------------------------------------------------------------------------

class TestExample(unittest.TestCase):
    &#39;&#39;&#39;
    This is a template to write new tests.
    &#39;&#39;&#39;
    def test_example(self):
        &#39;&#39;&#39;
        This is a template to write new tests.

            Output :
                The result is always True (a bool)
        &#39;&#39;&#39;
        self.assertTrue(True)

#-------------------------------------------------------------------------------

class TestGlobal(unittest.TestCase):
    &#39;&#39;&#39;
    Test global.
    &#39;&#39;&#39;
    def test_all_files_here(self):
        &#39;&#39;&#39;
        This test verifies that all files are in the directory.

            Output :
                The result is True if all files needed for a simulation are here (a bool)
        &#39;&#39;&#39;
        L_files = [&#39;Grain.py&#39;,
                   &#39;main_after_crash.py&#39;,
                   &#39;main.py&#39;,
                   &#39;Owntools/__init__.py&#39;,
                   &#39;Owntools/Debug_Diff_Solute_base.i&#39;,
                   &#39;Owntools/PFtoDEM_Multi.py&#39;,
                   &#39;Owntools/Plot.py&#39;,
                   &#39;Owntools/Save.py&#39;,
                   &#39;Owntools/Write.py&#39;,
                   &#39;PF_ACS_base.i&#39;,
                   &#39;Report.py&#39;,
                   &#39;User.py&#39;]
        AllHere = True
        MissingFiles = &#39;&#39;
        for file in L_files :
            plotpath = Path(file)
            if not plotpath.exists():
                MissingFiles = MissingFiles + &#39; &#39;+ file
                AllHere = False
        self.assertTrue(AllHere,&#39;Some files are missing :&#39;+MissingFiles)

    #---------------------------------------------------------------------------

    def test_main_iteration_main(self):
        &#39;&#39;&#39;
        This test verifies that one PFDEM iteration can be done.

            Output :
                No result, except if an error appears
        &#39;&#39;&#39;
        if Path(&#39;Input&#39;).exists():
            shutil.rmtree(&#39;Input&#39;)
        os.mkdir(&#39;Input&#39;)
        if Path(&#39;Output&#39;).exists():
            shutil.rmtree(&#39;Output&#39;)
        os.mkdir(&#39;Output&#39;)
        if Path(&#39;Data&#39;).exists():
            shutil.rmtree(&#39;Data&#39;)
        os.mkdir(&#39;Data&#39;)
        if Path(&#39;Debug&#39;).exists():
            shutil.rmtree(&#39;Debug&#39;)
        os.mkdir(&#39;Debug&#39;)

        #create a simulation report
        simulation_report = Report.Report(&#39;Debug/Report&#39;,datetime.now())
        simulation_report.tic_tempo(datetime.now())

        #general parameters
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        if dict_algorithm[&#39;SaveData&#39;]:
            if not Path(&#39;../&#39;+dict_algorithm[&#39;foldername&#39;]).exists():
                os.mkdir(&#39;../&#39;+dict_algorithm[&#39;foldername&#39;])
            #tempo save of the user file
            shutil.copy(&#39;User.py&#39;,&#39;../&#39;+dict_algorithm[&#39;foldername&#39;]+&#39;/User_&#39;+dict_algorithm[&#39;namefile&#39;]+&#39;_tempo.txt&#39;)

        #prepare plot
        if &#39;Config&#39; in dict_algorithm[&#39;L_flag_plot&#39;]:
            os.mkdir(&#39;Debug/Configuration&#39;)
        if &#39;Init_Current_Shape&#39; in dict_algorithm[&#39;L_flag_plot&#39;]:
            os.mkdir(&#39;Debug/Comparison_Init_Current&#39;)
        if &#39;Ed&#39; in dict_algorithm[&#39;L_flag_plot&#39;]:
            os.mkdir(&#39;Debug/Ed&#39;)
        if &#39;Kc&#39; in dict_algorithm[&#39;L_flag_plot&#39;]:
            os.mkdir(&#39;Debug/Kc&#39;)
        if &#39;Diff_Solute&#39; in dict_algorithm[&#39;L_flag_plot&#39;]:
            os.mkdir(&#39;Debug/Diff_Solute&#39;)

        #create the two grains
        User.Add_2grains(dict_material,dict_sample)
        #Compute initial sum_eta
        Owntools.Compute.Compute_sum_eta(dict_sample)
        #Compute the sphericity initially for the first grain
        dict_sample[&#39;L_g&#39;][0].geometric_study(dict_sample)
        dict_sample[&#39;L_g&#39;][0].Compute_sphericity(dict_algorithm)
        #create the solute
        User.Add_solute(dict_sample)
        simulation_report.tac_tempo(datetime.now(),&#39;Initialisation&#39;)

        #trackers
        dict_tracker = {
        &#39;L_t&#39; : [0],
        &#39;L_dt&#39; : [],
        &#39;L_sum_solute&#39; : [0],
        &#39;L_sum_eta&#39; : [dict_sample[&#39;sum_eta&#39;]],
        &#39;L_sum_total&#39; : [dict_sample[&#39;sum_eta&#39;]],
        &#39;L_area_sphericity_g0&#39; : [dict_sample[&#39;L_g&#39;][0].area_sphericity],
        &#39;L_diameter_sphericity_g0&#39; : [dict_sample[&#39;L_g&#39;][0].diameter_sphericity],
        &#39;L_circle_ratio_sphericity_g0&#39; : [dict_sample[&#39;L_g&#39;][0].circle_ratio_sphericity],
        &#39;L_perimeter_sphericity_g0&#39; : [dict_sample[&#39;L_g&#39;][0].perimeter_sphericity],
        &#39;L_width_to_length_ratio_sphericity_g0&#39; : [dict_sample[&#39;L_g&#39;][0].width_to_length_ratio_sphericity],
        &#39;sum_ed_L&#39;: [],
        &#39;sum_Ed_che_L&#39;: [],
        &#39;sum_Ed_mec_L&#39;: [],
        &#39;sum_ed_plus_L&#39; : [],
        &#39;sum_ed_minus_L&#39; : []
        }

        #Try to run one iteration
        dict_algorithm[&#39;i_PFDEM&#39;] = 0
        iteration_main(dict_algorithm, dict_material, dict_sample, dict_sollicitation, dict_tracker, simulation_report)

#-------------------------------------------------------------------------------

class TestReport(unittest.TestCase):
    &#39;&#39;&#39;Test functions from Report.py.&#39;&#39;&#39;
    def test_Report(self):
        &#39;&#39;&#39;
        Try to generate a report.txt file.

            Output :
                The result depends on the fact if the file is well generated or not (a bool)
        &#39;&#39;&#39;
        #try to create a report.txt file
        simulation_report = Report.Report(&#39;Report&#39;,datetime.now())
        #check if the .txt has been created
        self.assertTrue(Path(&#39;Report.txt&#39;).is_file(),&#34;The file Report.txt has not been created by the function Report.Report()!&#34;)
        os.remove(&#39;Report.txt&#39;)

#-------------------------------------------------------------------------------

class TestUser(unittest.TestCase):
    &#39;&#39;&#39;Test functions from User.py.&#39;&#39;&#39;
    def test_All_parameters(self):
        &#39;&#39;&#39;
        Try to acquire data from the function User.All_parameters().

            Output :
                The result depends on the fact if data are well acquired or not (a bool)
        &#39;&#39;&#39;
        #try to acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        #check if all data are dictionnaries
        self.assertTrue((type(dict_algorithm) is dict) and (type(dict_material) is dict) and (type(dict_sample) is dict) and (type(dict_sollicitation) is dict),&#39;Outputs from User.All_parameters() are not dictionaries!&#39;)

    #---------------------------------------------------------------------------

    def test_Add_2grains(self):
        &#39;&#39;&#39;
        Try to generate two grains with the function User.Add_2grains().

            Output :
                The result depends on the fact if grains are well generated or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        #try to create 2 grains
        User.Add_2grains(dict_material,dict_sample)
        #check if there are 2 grains
        self.assertTrue(len(dict_sample[&#39;L_g&#39;])==2,&#39;The function User.Add_2grains does not create 2 grains!&#39;)

    #---------------------------------------------------------------------------

    def test_Add_solute(self):
        &#39;&#39;&#39;
        Try to generate a solute with the function User.Add_solute().

            Output :
                The result depends on the fact if solute is well generated or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        #try to create 2 grains
        User.Add_solute(dict_sample)
        #check if there are 2 grains
        self.assertTrue(&#39;solute_M&#39; in dict_sample.keys(),&#39;The function User.Add_solute does not create a solute!&#39;)

#-------------------------------------------------------------------------------

class TestOwntools(unittest.TestCase):
    &#39;&#39;&#39;Test functions from Owntools.py.&#39;&#39;&#39;
    def test_is_PF_ACS_base_here(self):
        &#39;&#39;&#39;
        Verify if the template PF_ACS_base.i is in the directory.

        This file is used to generated MOOSE simulation input file.

            Output :
                The result depends on the fact if the file is here or not (a bool)
        &#39;&#39;&#39;
        #Check if the file PF_ACS_base.i is in the directory
        self.assertTrue(Path(&#39;PF_ACS_base.i&#39;).is_file(),&#34;The file PF_CH_AC_base.i should exists!&#34;)

    #---------------------------------------------------------------------------

    def test_Write_i(self):
        &#39;&#39;&#39;
        Try to create a MOOSE simulation input file with Owntools.Write.Write_i().

        This file is created from the template PF_ACS_base.i.

            Output :
                The result depends on the fact if the file is well created or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        dict_algorithm[&#39;i_PFDEM&#39;] = 0
        #try to create a .i file
        Owntools.Write.Write_i(dict_algorithm, dict_material, dict_sample, dict_sollicitation)
        #Check if the file PF_CH_AC_base.i is in the directory
        self.assertTrue(Path(dict_algorithm[&#39;namefile&#39;]+&#39;_&#39;+str(dict_algorithm[&#39;i_PFDEM&#39;])+&#39;.i&#39;).is_file(),&#34;The file namefile.i has not been created!&#34;)
        os.remove(dict_algorithm[&#39;namefile&#39;]+&#39;_&#39;+str(dict_algorithm[&#39;i_PFDEM&#39;])+&#39;.i&#39;)

    #---------------------------------------------------------------------------

    def test_index_to_str(self):
        &#39;&#39;&#39;
        Try to convert an integer into a string with Owntools.index_to_str().

        The string is composed by three elements.

            Output :
                The result depends on the fact if the conversions are well done or not (a bool)
        &#39;&#39;&#39;
        #check if the function works well in different configurations
        self.assertTrue(Owntools.index_to_str(7)==&#39;007&#39;,&#39;The conversion index_to_str() seems to do not for 00x...&#39;)
        self.assertTrue(Owntools.index_to_str(26)==&#39;026&#39;,&#39;The conversion index_to_str() seems to do not for 0xx...&#39;)
        self.assertTrue(Owntools.index_to_str(666)==&#39;666&#39;,&#39;The conversion index_to_str() seems to do not for xxx...&#39;)

    #---------------------------------------------------------------------------

    def test_Plot_config(self):
        &#39;&#39;&#39;
        Try to plot a sample configuration with Owntools.Plot_config().

            Output :
                The result depends on the fact if the .png file is well created or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        #create the two grains
        User.Add_2grains(dict_material,dict_sample)
        #create the solute
        User.Add_solute(dict_sample)
        #create a folder
        if Path(&#39;Debug&#39;).exists():
            shutil.rmtree(&#39;Debug&#39;)
        os.mkdir(&#39;Debug&#39;)
        os.mkdir(&#39;Debug/Configuration&#39;)
        #try to plot the configuration
        Owntools.Plot.Plot_config(dict_algorithm, dict_sample)
        #check if the .png has been created
        self.assertTrue(Path(&#39;Debug/Configuration/Configuration_0.png&#39;).is_file(),&#34;The image Debug/Configuration/Configuration_0.png has not been created by the function Owntools.Plot_config()!&#34;)
        shutil.rmtree(&#39;Debug&#39;)

    #---------------------------------------------------------------------------

    def test_Cosine_Profile(self):
        &#39;&#39;&#39;
        Try to compute a phase variable with Owntools.Cosine_Profile().

        Three cases are considered : inside the grain, at the interface, outside the grain.

            Output :
                The result depends on the fact if the phase variable is well computed or not (a bool)
        &#39;&#39;&#39;
        #check if the function works well in different configurations
        self.assertTrue(Owntools.Cosine_Profile(1,0,0.5)==1,&#39;The Owntools.Cosine_Profile() seems to do not for a point inside the grain...&#39;)
        self.assertTrue(Owntools.Cosine_Profile(1,1,0.5)==0.5*(1 + math.cos(math.pi/2)),&#39;The Owntools.Cosine_Profile() seems to do not for a point inside the interface...&#39;)
        self.assertTrue(Owntools.Cosine_Profile(1,2,0.5)==0,&#39;The Owntools.Cosine_Profile() seems to do not for a point outside the grain...&#39;)

    #---------------------------------------------------------------------------

    def test_Write_eta_txt(self):
        &#39;&#39;&#39;
        Try to create file needed for MOOSE simulation with Owntools.Write_eta_txt().

        This file is about etai variables.
        A sample with two grains is assumed.

            Output :
                The result depends on the fact if the file is well created or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        dict_algorithm[&#39;i_PFDEM&#39;] = 0
        #create the two grains
        User.Add_2grains(dict_material,dict_sample)
        #create a folder
        if Path(&#39;Data&#39;).exists():
            shutil.rmtree(&#39;Data&#39;)
        os.mkdir(&#39;Data&#39;)
        #try to create .txt files
        Owntools.Write.Write_eta_txt(dict_algorithm, dict_sample)
        #Check if the files are in the directory
        self.assertTrue(Path(&#39;Data/eta1_0.txt&#39;).is_file(),&#34;The file Data/eta1_0.txt has not been created!&#34;)
        self.assertTrue(Path(&#39;Data/eta2_0.txt&#39;).is_file(),&#34;The file Data/eta2_0.txt has not been created!&#34;)
        shutil.rmtree(&#39;Data&#39;)

    #---------------------------------------------------------------------------

    def test_Write_solute_txt(self):
        &#39;&#39;&#39;
        Try to create file needed for MOOSE simulation with Owntools.Write_solute_txt().

        This file is about c variable.

            Output :
                The result depends on the fact if the file is well created or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        dict_algorithm[&#39;i_PFDEM&#39;] = 0
        #create the two grains
        User.Add_solute(dict_sample)
        #create a folder
        if Path(&#39;Data&#39;).exists():
            shutil.rmtree(&#39;Data&#39;)
        os.mkdir(&#39;Data&#39;)
        #try to create .txt files
        Owntools.Write.Write_solute_txt(dict_algorithm, dict_sample)
        #Check if the files are in the directory
        self.assertTrue(Path(&#39;Data/c_0.txt&#39;).is_file(),&#34;The file Data/c_0.txt has not been created!&#34;)
        shutil.rmtree(&#39;Data&#39;)

    #---------------------------------------------------------------------------

    def test_Write_Emec_txt(self):
        &#39;&#39;&#39;
        Try to create file needed for MOOSE simulation with Owntools.Write_Emec_txt().

        This file is about the dissolution field due to mechanical loading.

            Output :
                The result depends on the fact if the file is well created or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        dict_algorithm[&#39;i_PFDEM&#39;] = 0
        #create the two grains
        User.Add_2grains(dict_material,dict_sample)
        #create a folder
        if Path(&#39;Data&#39;).exists():
            shutil.rmtree(&#39;Data&#39;)
        os.mkdir(&#39;Data&#39;)
        #try to create .txt files
        Owntools.Write.Write_Emec_txt(dict_algorithm, dict_sample)
        #Check if the files are in the directory
        self.assertTrue(Path(&#39;Data/ep_0.txt&#39;).is_file(),&#34;The file Data/ep_0.txt has not been created!&#34;)
        shutil.rmtree(&#39;Data&#39;)

    #---------------------------------------------------------------------------

    def test_Write_kc_txt(self):
        &#39;&#39;&#39;
        Try to create file needed for MOOSE simulation with Owntools.Write_kc_txt().

        This file is about the diffusion of the solute.

            Output :
                The result depends on the fact if the file is well created or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        dict_algorithm[&#39;i_PFDEM&#39;] = 0
        #create the two grains
        User.Add_2grains(dict_material,dict_sample)
        #create a folder
        if Path(&#39;Data&#39;).exists():
            shutil.rmtree(&#39;Data&#39;)
        os.mkdir(&#39;Data&#39;)
        #Compute the diffusion coefficient
        Owntools.Compute.Compute_kc_dil(dict_algorithm, dict_material,dict_sample)
        #try to create .txt files
        Owntools.Write.Write_kc_txt(dict_algorithm, dict_sample)
        #Check if the files are in the directory
        self.assertTrue(Path(&#39;Data/kc_0.txt&#39;).is_file(),&#34;The file Data/kc_0.txt has not been created!&#34;)
        shutil.rmtree(&#39;Data&#39;)

#-------------------------------------------------------------------------------

class TestGrain(unittest.TestCase):
    &#39;&#39;&#39;Test functions from Grain.py.&#39;&#39;&#39;
    def test_geometric_study(self):
        &#39;&#39;&#39;
        Try to study the grain geometry with Grain.geometric_study().

        As Monte Carlo is used, some noise can occur. It is advised to test multiple times.

            Output :
                The result depends on the fact if the center is well located or not (a bool)
                The result depends on the fact if the surface is well assumed or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        #Create one grain
        grain = Grain.Grain(0,10,np.array([np.mean(dict_sample[&#39;x_L&#39;]),np.mean(dict_sample[&#39;y_L&#39;])]),dict_material,dict_sample)
        #try to do the geometric study of the grain
        grain.geometric_study(dict_sample)
        #define margine of the surface and the center (the study is done with a Monte Carlo method, some noise can be introduced)
        margin_center = 0.03*10 #10 is the radius see line upper
        margin_surface = 0.03*math.pi*10**2 #10 is the radius see line upper
        #check if the center computed is near the analytical one
        self.assertTrue(np.linalg.norm(np.array([np.mean(dict_sample[&#39;x_L&#39;]),np.mean(dict_sample[&#39;y_L&#39;])])-grain.center)&lt;margin_center,&#39;The estimation of the center position seems false (because of the Monte Carlo Method try to rerun or increase the margin)...&#39;)
        #check if the surface computed is near the analytical one
        self.assertTrue(abs(math.pi*10**2-grain.surface)&lt;margin_surface,&#39;The estimation of the surface seems false (because of the Monte Carlo Method try to rerun or increase the margin)...&#39;)

    #---------------------------------------------------------------------------

    def test_P_is_inside(self):
        &#39;&#39;&#39;
        Try to determine if a point is inside a grain geometry with Grain.P_is_inside().

        Two cases are considered : the point is inside, the point is outside.

            Output :
                The result depends on the fact if points are well located or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        #Create one grain
        grain = Grain.Grain(0,10,np.array([np.mean(dict_sample[&#39;x_L&#39;]),np.mean(dict_sample[&#39;y_L&#39;])]),dict_material,dict_sample)
        #check if the function works well in different configurations
        self.assertFalse(grain.P_is_inside(np.array([np.mean(dict_sample[&#39;x_L&#39;])+11,np.mean(dict_sample[&#39;y_L&#39;])])),&#39;An outside point is detected as inside by Grain.P_is_inside()...&#39;)
        self.assertTrue(grain.P_is_inside(np.array([np.mean(dict_sample[&#39;x_L&#39;]),np.mean(dict_sample[&#39;y_L&#39;])+1])),&#39;An inside point is detected as outside by Grain.P_is_inside()...&#39;)

    #---------------------------------------------------------------------------

    def test_move_grain_rebuild(self):
        &#39;&#39;&#39;
        Try to move a grain by deconstruction and rebuild with Grain.move_grain_rebuild().

        As Monte Carlo is used, some noise can occur. It is advised to test multiple times.

            Output :
                The result depends on the fact if the grain is well moved or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        #Create one grain
        grain = Grain.Grain(0,10,np.array([np.mean(dict_sample[&#39;x_L&#39;]),np.mean(dict_sample[&#39;y_L&#39;])]),dict_material,dict_sample)
        #try to move the grain
        grain.move_grain_rebuild(np.array([5,0]),dict_material,dict_sample)
        #check if the center computed is near the analytical one
        self.assertTrue(np.linalg.norm(np.array([np.mean(dict_sample[&#39;x_L&#39;])+5,np.mean(dict_sample[&#39;y_L&#39;])])-grain.center)==0,&#39;The grain has not been well moved!&#39;)
        #Study the geometric of the grain
        grain.geometric_study(dict_sample)
        #define margine of the new center (the study is done with a Monte Carlo method, some noise can be introduced)
        margin_center = 0.03*10 #10 is the radius see line upper
        #check if the center computed is near the analytical one
        self.assertTrue(np.linalg.norm(np.array([np.mean(dict_sample[&#39;x_L&#39;])+5,np.mean(dict_sample[&#39;y_L&#39;])])-grain.center)&lt;margin_center,&#39;The displacement of the grain seems false after the etai_M rebuild (because of the Monte Carlo Method try to rerun or increase the margin)...&#39;)

    #---------------------------------------------------------------------------

    def test_move_grain_interpolation(self):
        &#39;&#39;&#39;
        Try to move a grain by interpolation with Grain.move_grain_interpolation().

        As Monte Carlo is used, some noise can occur. It is advised to test multiple times.

            Output :
                The result depends on the fact if the grain is well moved or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        #Create one grain
        grain = Grain.Grain(0,10,np.array([np.mean(dict_sample[&#39;x_L&#39;]),np.mean(dict_sample[&#39;y_L&#39;])]),dict_material,dict_sample)
        #try to move the grain
        grain.move_grain_interpolation(np.array([5,0]),dict_sample)
        #check if the center computed is near the analytical one
        self.assertTrue(np.linalg.norm(np.array([np.mean(dict_sample[&#39;x_L&#39;])+5,np.mean(dict_sample[&#39;y_L&#39;])])-grain.center)==0,&#39;The grain has not been well moved!&#39;)
        #Study the geometric of the grain
        grain.geometric_study(dict_sample)
        #define margine of the new center (the study is done with a Monte Carlo method, some noise can be introduced)
        margin_center = 0.03*10 #10 is the radius see line upper
        #check if the center computed is near the analytical one
        self.assertTrue(np.linalg.norm(np.array([np.mean(dict_sample[&#39;x_L&#39;])+5,np.mean(dict_sample[&#39;y_L&#39;])])-grain.center)&lt;margin_center,&#39;The displacement of the grain seems false after the etai_M rebuild (because of the Monte Carlo Method try to rerun or increase the margin)...&#39;)

    #---------------------------------------------------------------------------

    def test_Compute_overlap_2_grains(self):
        &#39;&#39;&#39;
        Try to compute the overlap between two grains with Grain.Compute_overlap_2_grains().

        Two cases are considered : 2 grains in contact, 2 grains not in contact.

            Output :
                The result depends on the fact if the overlap are well computed or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        dict_sample[&#39;grain_discretisation&#39;] = 20
        #Create two grain
        g1 = Grain.Grain(0,10,np.array([np.mean(dict_sample[&#39;x_L&#39;])-5,np.mean(dict_sample[&#39;y_L&#39;])]),dict_material,dict_sample)
        g2 = Grain.Grain(0,10,np.array([np.mean(dict_sample[&#39;x_L&#39;])+5,np.mean(dict_sample[&#39;y_L&#39;])]),dict_material,dict_sample)
        dict_sample[&#39;L_g&#39;] = [g1,g2]
        #Check if there is an overlap between those grains
        Grain.Compute_overlap_2_grains(dict_sample)
        self.assertTrue(dict_sample[&#39;overlap&#39;]==10,&#39;The overlap between two grains in contact is not well computed!&#39;)
        #Create two grain
        g1 = Grain.Grain(0,10,np.array([np.mean(dict_sample[&#39;x_L&#39;])-11,np.mean(dict_sample[&#39;y_L&#39;])]),dict_material,dict_sample)
        g2 = Grain.Grain(0,10,np.array([np.mean(dict_sample[&#39;x_L&#39;])+11,np.mean(dict_sample[&#39;y_L&#39;])]),dict_material,dict_sample)
        dict_sample[&#39;L_g&#39;] = [g1,g2]
        #Check if there is not an overlap between those grains
        Grain.Compute_overlap_2_grains(dict_sample)
        self.assertTrue(dict_sample[&#39;overlap&#39;]==-2,&#39;The overlap between two grains not in contact is not well computed!&#39;)

#-------------------------------------------------------------------------------
#main
#-------------------------------------------------------------------------------
if &#39;__main__&#39; == __name__:
    unittest.main(verbosity = 2)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="test.TestExample"><code class="flex name class">
<span>class <span class="ident">TestExample</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<div class="desc"><p>This is a template to write new tests.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TestExample(unittest.TestCase):
    &#39;&#39;&#39;
    This is a template to write new tests.
    &#39;&#39;&#39;
    def test_example(self):
        &#39;&#39;&#39;
        This is a template to write new tests.

            Output :
                The result is always True (a bool)
        &#39;&#39;&#39;
        self.assertTrue(True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="test.TestExample.test_example"><code class="name flex">
<span>def <span class="ident">test_example</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a template to write new tests.</p>
<pre><code>Output :
    The result is always True (a bool)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_example(self):
    &#39;&#39;&#39;
    This is a template to write new tests.

        Output :
            The result is always True (a bool)
    &#39;&#39;&#39;
    self.assertTrue(True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="test.TestGlobal"><code class="flex name class">
<span>class <span class="ident">TestGlobal</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<div class="desc"><p>Test global.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TestGlobal(unittest.TestCase):
    &#39;&#39;&#39;
    Test global.
    &#39;&#39;&#39;
    def test_all_files_here(self):
        &#39;&#39;&#39;
        This test verifies that all files are in the directory.

            Output :
                The result is True if all files needed for a simulation are here (a bool)
        &#39;&#39;&#39;
        L_files = [&#39;Grain.py&#39;,
                   &#39;main_after_crash.py&#39;,
                   &#39;main.py&#39;,
                   &#39;Owntools/__init__.py&#39;,
                   &#39;Owntools/Debug_Diff_Solute_base.i&#39;,
                   &#39;Owntools/PFtoDEM_Multi.py&#39;,
                   &#39;Owntools/Plot.py&#39;,
                   &#39;Owntools/Save.py&#39;,
                   &#39;Owntools/Write.py&#39;,
                   &#39;PF_ACS_base.i&#39;,
                   &#39;Report.py&#39;,
                   &#39;User.py&#39;]
        AllHere = True
        MissingFiles = &#39;&#39;
        for file in L_files :
            plotpath = Path(file)
            if not plotpath.exists():
                MissingFiles = MissingFiles + &#39; &#39;+ file
                AllHere = False
        self.assertTrue(AllHere,&#39;Some files are missing :&#39;+MissingFiles)

    #---------------------------------------------------------------------------

    def test_main_iteration_main(self):
        &#39;&#39;&#39;
        This test verifies that one PFDEM iteration can be done.

            Output :
                No result, except if an error appears
        &#39;&#39;&#39;
        if Path(&#39;Input&#39;).exists():
            shutil.rmtree(&#39;Input&#39;)
        os.mkdir(&#39;Input&#39;)
        if Path(&#39;Output&#39;).exists():
            shutil.rmtree(&#39;Output&#39;)
        os.mkdir(&#39;Output&#39;)
        if Path(&#39;Data&#39;).exists():
            shutil.rmtree(&#39;Data&#39;)
        os.mkdir(&#39;Data&#39;)
        if Path(&#39;Debug&#39;).exists():
            shutil.rmtree(&#39;Debug&#39;)
        os.mkdir(&#39;Debug&#39;)

        #create a simulation report
        simulation_report = Report.Report(&#39;Debug/Report&#39;,datetime.now())
        simulation_report.tic_tempo(datetime.now())

        #general parameters
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        if dict_algorithm[&#39;SaveData&#39;]:
            if not Path(&#39;../&#39;+dict_algorithm[&#39;foldername&#39;]).exists():
                os.mkdir(&#39;../&#39;+dict_algorithm[&#39;foldername&#39;])
            #tempo save of the user file
            shutil.copy(&#39;User.py&#39;,&#39;../&#39;+dict_algorithm[&#39;foldername&#39;]+&#39;/User_&#39;+dict_algorithm[&#39;namefile&#39;]+&#39;_tempo.txt&#39;)

        #prepare plot
        if &#39;Config&#39; in dict_algorithm[&#39;L_flag_plot&#39;]:
            os.mkdir(&#39;Debug/Configuration&#39;)
        if &#39;Init_Current_Shape&#39; in dict_algorithm[&#39;L_flag_plot&#39;]:
            os.mkdir(&#39;Debug/Comparison_Init_Current&#39;)
        if &#39;Ed&#39; in dict_algorithm[&#39;L_flag_plot&#39;]:
            os.mkdir(&#39;Debug/Ed&#39;)
        if &#39;Kc&#39; in dict_algorithm[&#39;L_flag_plot&#39;]:
            os.mkdir(&#39;Debug/Kc&#39;)
        if &#39;Diff_Solute&#39; in dict_algorithm[&#39;L_flag_plot&#39;]:
            os.mkdir(&#39;Debug/Diff_Solute&#39;)

        #create the two grains
        User.Add_2grains(dict_material,dict_sample)
        #Compute initial sum_eta
        Owntools.Compute.Compute_sum_eta(dict_sample)
        #Compute the sphericity initially for the first grain
        dict_sample[&#39;L_g&#39;][0].geometric_study(dict_sample)
        dict_sample[&#39;L_g&#39;][0].Compute_sphericity(dict_algorithm)
        #create the solute
        User.Add_solute(dict_sample)
        simulation_report.tac_tempo(datetime.now(),&#39;Initialisation&#39;)

        #trackers
        dict_tracker = {
        &#39;L_t&#39; : [0],
        &#39;L_dt&#39; : [],
        &#39;L_sum_solute&#39; : [0],
        &#39;L_sum_eta&#39; : [dict_sample[&#39;sum_eta&#39;]],
        &#39;L_sum_total&#39; : [dict_sample[&#39;sum_eta&#39;]],
        &#39;L_area_sphericity_g0&#39; : [dict_sample[&#39;L_g&#39;][0].area_sphericity],
        &#39;L_diameter_sphericity_g0&#39; : [dict_sample[&#39;L_g&#39;][0].diameter_sphericity],
        &#39;L_circle_ratio_sphericity_g0&#39; : [dict_sample[&#39;L_g&#39;][0].circle_ratio_sphericity],
        &#39;L_perimeter_sphericity_g0&#39; : [dict_sample[&#39;L_g&#39;][0].perimeter_sphericity],
        &#39;L_width_to_length_ratio_sphericity_g0&#39; : [dict_sample[&#39;L_g&#39;][0].width_to_length_ratio_sphericity],
        &#39;sum_ed_L&#39;: [],
        &#39;sum_Ed_che_L&#39;: [],
        &#39;sum_Ed_mec_L&#39;: [],
        &#39;sum_ed_plus_L&#39; : [],
        &#39;sum_ed_minus_L&#39; : []
        }

        #Try to run one iteration
        dict_algorithm[&#39;i_PFDEM&#39;] = 0
        iteration_main(dict_algorithm, dict_material, dict_sample, dict_sollicitation, dict_tracker, simulation_report)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="test.TestGlobal.test_all_files_here"><code class="name flex">
<span>def <span class="ident">test_all_files_here</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This test verifies that all files are in the directory.</p>
<pre><code>Output :
    The result is True if all files needed for a simulation are here (a bool)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_all_files_here(self):
    &#39;&#39;&#39;
    This test verifies that all files are in the directory.

        Output :
            The result is True if all files needed for a simulation are here (a bool)
    &#39;&#39;&#39;
    L_files = [&#39;Grain.py&#39;,
               &#39;main_after_crash.py&#39;,
               &#39;main.py&#39;,
               &#39;Owntools/__init__.py&#39;,
               &#39;Owntools/Debug_Diff_Solute_base.i&#39;,
               &#39;Owntools/PFtoDEM_Multi.py&#39;,
               &#39;Owntools/Plot.py&#39;,
               &#39;Owntools/Save.py&#39;,
               &#39;Owntools/Write.py&#39;,
               &#39;PF_ACS_base.i&#39;,
               &#39;Report.py&#39;,
               &#39;User.py&#39;]
    AllHere = True
    MissingFiles = &#39;&#39;
    for file in L_files :
        plotpath = Path(file)
        if not plotpath.exists():
            MissingFiles = MissingFiles + &#39; &#39;+ file
            AllHere = False
    self.assertTrue(AllHere,&#39;Some files are missing :&#39;+MissingFiles)</code></pre>
</details>
</dd>
<dt id="test.TestGlobal.test_main_iteration_main"><code class="name flex">
<span>def <span class="ident">test_main_iteration_main</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This test verifies that one PFDEM iteration can be done.</p>
<pre><code>Output :
    No result, except if an error appears
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_main_iteration_main(self):
    &#39;&#39;&#39;
    This test verifies that one PFDEM iteration can be done.

        Output :
            No result, except if an error appears
    &#39;&#39;&#39;
    if Path(&#39;Input&#39;).exists():
        shutil.rmtree(&#39;Input&#39;)
    os.mkdir(&#39;Input&#39;)
    if Path(&#39;Output&#39;).exists():
        shutil.rmtree(&#39;Output&#39;)
    os.mkdir(&#39;Output&#39;)
    if Path(&#39;Data&#39;).exists():
        shutil.rmtree(&#39;Data&#39;)
    os.mkdir(&#39;Data&#39;)
    if Path(&#39;Debug&#39;).exists():
        shutil.rmtree(&#39;Debug&#39;)
    os.mkdir(&#39;Debug&#39;)

    #create a simulation report
    simulation_report = Report.Report(&#39;Debug/Report&#39;,datetime.now())
    simulation_report.tic_tempo(datetime.now())

    #general parameters
    dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
    if dict_algorithm[&#39;SaveData&#39;]:
        if not Path(&#39;../&#39;+dict_algorithm[&#39;foldername&#39;]).exists():
            os.mkdir(&#39;../&#39;+dict_algorithm[&#39;foldername&#39;])
        #tempo save of the user file
        shutil.copy(&#39;User.py&#39;,&#39;../&#39;+dict_algorithm[&#39;foldername&#39;]+&#39;/User_&#39;+dict_algorithm[&#39;namefile&#39;]+&#39;_tempo.txt&#39;)

    #prepare plot
    if &#39;Config&#39; in dict_algorithm[&#39;L_flag_plot&#39;]:
        os.mkdir(&#39;Debug/Configuration&#39;)
    if &#39;Init_Current_Shape&#39; in dict_algorithm[&#39;L_flag_plot&#39;]:
        os.mkdir(&#39;Debug/Comparison_Init_Current&#39;)
    if &#39;Ed&#39; in dict_algorithm[&#39;L_flag_plot&#39;]:
        os.mkdir(&#39;Debug/Ed&#39;)
    if &#39;Kc&#39; in dict_algorithm[&#39;L_flag_plot&#39;]:
        os.mkdir(&#39;Debug/Kc&#39;)
    if &#39;Diff_Solute&#39; in dict_algorithm[&#39;L_flag_plot&#39;]:
        os.mkdir(&#39;Debug/Diff_Solute&#39;)

    #create the two grains
    User.Add_2grains(dict_material,dict_sample)
    #Compute initial sum_eta
    Owntools.Compute.Compute_sum_eta(dict_sample)
    #Compute the sphericity initially for the first grain
    dict_sample[&#39;L_g&#39;][0].geometric_study(dict_sample)
    dict_sample[&#39;L_g&#39;][0].Compute_sphericity(dict_algorithm)
    #create the solute
    User.Add_solute(dict_sample)
    simulation_report.tac_tempo(datetime.now(),&#39;Initialisation&#39;)

    #trackers
    dict_tracker = {
    &#39;L_t&#39; : [0],
    &#39;L_dt&#39; : [],
    &#39;L_sum_solute&#39; : [0],
    &#39;L_sum_eta&#39; : [dict_sample[&#39;sum_eta&#39;]],
    &#39;L_sum_total&#39; : [dict_sample[&#39;sum_eta&#39;]],
    &#39;L_area_sphericity_g0&#39; : [dict_sample[&#39;L_g&#39;][0].area_sphericity],
    &#39;L_diameter_sphericity_g0&#39; : [dict_sample[&#39;L_g&#39;][0].diameter_sphericity],
    &#39;L_circle_ratio_sphericity_g0&#39; : [dict_sample[&#39;L_g&#39;][0].circle_ratio_sphericity],
    &#39;L_perimeter_sphericity_g0&#39; : [dict_sample[&#39;L_g&#39;][0].perimeter_sphericity],
    &#39;L_width_to_length_ratio_sphericity_g0&#39; : [dict_sample[&#39;L_g&#39;][0].width_to_length_ratio_sphericity],
    &#39;sum_ed_L&#39;: [],
    &#39;sum_Ed_che_L&#39;: [],
    &#39;sum_Ed_mec_L&#39;: [],
    &#39;sum_ed_plus_L&#39; : [],
    &#39;sum_ed_minus_L&#39; : []
    }

    #Try to run one iteration
    dict_algorithm[&#39;i_PFDEM&#39;] = 0
    iteration_main(dict_algorithm, dict_material, dict_sample, dict_sollicitation, dict_tracker, simulation_report)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="test.TestGrain"><code class="flex name class">
<span>class <span class="ident">TestGrain</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<div class="desc"><p>Test functions from Grain.py.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TestGrain(unittest.TestCase):
    &#39;&#39;&#39;Test functions from Grain.py.&#39;&#39;&#39;
    def test_geometric_study(self):
        &#39;&#39;&#39;
        Try to study the grain geometry with Grain.geometric_study().

        As Monte Carlo is used, some noise can occur. It is advised to test multiple times.

            Output :
                The result depends on the fact if the center is well located or not (a bool)
                The result depends on the fact if the surface is well assumed or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        #Create one grain
        grain = Grain.Grain(0,10,np.array([np.mean(dict_sample[&#39;x_L&#39;]),np.mean(dict_sample[&#39;y_L&#39;])]),dict_material,dict_sample)
        #try to do the geometric study of the grain
        grain.geometric_study(dict_sample)
        #define margine of the surface and the center (the study is done with a Monte Carlo method, some noise can be introduced)
        margin_center = 0.03*10 #10 is the radius see line upper
        margin_surface = 0.03*math.pi*10**2 #10 is the radius see line upper
        #check if the center computed is near the analytical one
        self.assertTrue(np.linalg.norm(np.array([np.mean(dict_sample[&#39;x_L&#39;]),np.mean(dict_sample[&#39;y_L&#39;])])-grain.center)&lt;margin_center,&#39;The estimation of the center position seems false (because of the Monte Carlo Method try to rerun or increase the margin)...&#39;)
        #check if the surface computed is near the analytical one
        self.assertTrue(abs(math.pi*10**2-grain.surface)&lt;margin_surface,&#39;The estimation of the surface seems false (because of the Monte Carlo Method try to rerun or increase the margin)...&#39;)

    #---------------------------------------------------------------------------

    def test_P_is_inside(self):
        &#39;&#39;&#39;
        Try to determine if a point is inside a grain geometry with Grain.P_is_inside().

        Two cases are considered : the point is inside, the point is outside.

            Output :
                The result depends on the fact if points are well located or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        #Create one grain
        grain = Grain.Grain(0,10,np.array([np.mean(dict_sample[&#39;x_L&#39;]),np.mean(dict_sample[&#39;y_L&#39;])]),dict_material,dict_sample)
        #check if the function works well in different configurations
        self.assertFalse(grain.P_is_inside(np.array([np.mean(dict_sample[&#39;x_L&#39;])+11,np.mean(dict_sample[&#39;y_L&#39;])])),&#39;An outside point is detected as inside by Grain.P_is_inside()...&#39;)
        self.assertTrue(grain.P_is_inside(np.array([np.mean(dict_sample[&#39;x_L&#39;]),np.mean(dict_sample[&#39;y_L&#39;])+1])),&#39;An inside point is detected as outside by Grain.P_is_inside()...&#39;)

    #---------------------------------------------------------------------------

    def test_move_grain_rebuild(self):
        &#39;&#39;&#39;
        Try to move a grain by deconstruction and rebuild with Grain.move_grain_rebuild().

        As Monte Carlo is used, some noise can occur. It is advised to test multiple times.

            Output :
                The result depends on the fact if the grain is well moved or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        #Create one grain
        grain = Grain.Grain(0,10,np.array([np.mean(dict_sample[&#39;x_L&#39;]),np.mean(dict_sample[&#39;y_L&#39;])]),dict_material,dict_sample)
        #try to move the grain
        grain.move_grain_rebuild(np.array([5,0]),dict_material,dict_sample)
        #check if the center computed is near the analytical one
        self.assertTrue(np.linalg.norm(np.array([np.mean(dict_sample[&#39;x_L&#39;])+5,np.mean(dict_sample[&#39;y_L&#39;])])-grain.center)==0,&#39;The grain has not been well moved!&#39;)
        #Study the geometric of the grain
        grain.geometric_study(dict_sample)
        #define margine of the new center (the study is done with a Monte Carlo method, some noise can be introduced)
        margin_center = 0.03*10 #10 is the radius see line upper
        #check if the center computed is near the analytical one
        self.assertTrue(np.linalg.norm(np.array([np.mean(dict_sample[&#39;x_L&#39;])+5,np.mean(dict_sample[&#39;y_L&#39;])])-grain.center)&lt;margin_center,&#39;The displacement of the grain seems false after the etai_M rebuild (because of the Monte Carlo Method try to rerun or increase the margin)...&#39;)

    #---------------------------------------------------------------------------

    def test_move_grain_interpolation(self):
        &#39;&#39;&#39;
        Try to move a grain by interpolation with Grain.move_grain_interpolation().

        As Monte Carlo is used, some noise can occur. It is advised to test multiple times.

            Output :
                The result depends on the fact if the grain is well moved or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        #Create one grain
        grain = Grain.Grain(0,10,np.array([np.mean(dict_sample[&#39;x_L&#39;]),np.mean(dict_sample[&#39;y_L&#39;])]),dict_material,dict_sample)
        #try to move the grain
        grain.move_grain_interpolation(np.array([5,0]),dict_sample)
        #check if the center computed is near the analytical one
        self.assertTrue(np.linalg.norm(np.array([np.mean(dict_sample[&#39;x_L&#39;])+5,np.mean(dict_sample[&#39;y_L&#39;])])-grain.center)==0,&#39;The grain has not been well moved!&#39;)
        #Study the geometric of the grain
        grain.geometric_study(dict_sample)
        #define margine of the new center (the study is done with a Monte Carlo method, some noise can be introduced)
        margin_center = 0.03*10 #10 is the radius see line upper
        #check if the center computed is near the analytical one
        self.assertTrue(np.linalg.norm(np.array([np.mean(dict_sample[&#39;x_L&#39;])+5,np.mean(dict_sample[&#39;y_L&#39;])])-grain.center)&lt;margin_center,&#39;The displacement of the grain seems false after the etai_M rebuild (because of the Monte Carlo Method try to rerun or increase the margin)...&#39;)

    #---------------------------------------------------------------------------

    def test_Compute_overlap_2_grains(self):
        &#39;&#39;&#39;
        Try to compute the overlap between two grains with Grain.Compute_overlap_2_grains().

        Two cases are considered : 2 grains in contact, 2 grains not in contact.

            Output :
                The result depends on the fact if the overlap are well computed or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        dict_sample[&#39;grain_discretisation&#39;] = 20
        #Create two grain
        g1 = Grain.Grain(0,10,np.array([np.mean(dict_sample[&#39;x_L&#39;])-5,np.mean(dict_sample[&#39;y_L&#39;])]),dict_material,dict_sample)
        g2 = Grain.Grain(0,10,np.array([np.mean(dict_sample[&#39;x_L&#39;])+5,np.mean(dict_sample[&#39;y_L&#39;])]),dict_material,dict_sample)
        dict_sample[&#39;L_g&#39;] = [g1,g2]
        #Check if there is an overlap between those grains
        Grain.Compute_overlap_2_grains(dict_sample)
        self.assertTrue(dict_sample[&#39;overlap&#39;]==10,&#39;The overlap between two grains in contact is not well computed!&#39;)
        #Create two grain
        g1 = Grain.Grain(0,10,np.array([np.mean(dict_sample[&#39;x_L&#39;])-11,np.mean(dict_sample[&#39;y_L&#39;])]),dict_material,dict_sample)
        g2 = Grain.Grain(0,10,np.array([np.mean(dict_sample[&#39;x_L&#39;])+11,np.mean(dict_sample[&#39;y_L&#39;])]),dict_material,dict_sample)
        dict_sample[&#39;L_g&#39;] = [g1,g2]
        #Check if there is not an overlap between those grains
        Grain.Compute_overlap_2_grains(dict_sample)
        self.assertTrue(dict_sample[&#39;overlap&#39;]==-2,&#39;The overlap between two grains not in contact is not well computed!&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="test.TestGrain.test_Compute_overlap_2_grains"><code class="name flex">
<span>def <span class="ident">test_Compute_overlap_2_grains</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to compute the overlap between two grains with Grain.Compute_overlap_2_grains().</p>
<p>Two cases are considered : 2 grains in contact, 2 grains not in contact.</p>
<pre><code>Output :
    The result depends on the fact if the overlap are well computed or not (a bool)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_Compute_overlap_2_grains(self):
    &#39;&#39;&#39;
    Try to compute the overlap between two grains with Grain.Compute_overlap_2_grains().

    Two cases are considered : 2 grains in contact, 2 grains not in contact.

        Output :
            The result depends on the fact if the overlap are well computed or not (a bool)
    &#39;&#39;&#39;
    #Acquire data
    dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
    dict_sample[&#39;grain_discretisation&#39;] = 20
    #Create two grain
    g1 = Grain.Grain(0,10,np.array([np.mean(dict_sample[&#39;x_L&#39;])-5,np.mean(dict_sample[&#39;y_L&#39;])]),dict_material,dict_sample)
    g2 = Grain.Grain(0,10,np.array([np.mean(dict_sample[&#39;x_L&#39;])+5,np.mean(dict_sample[&#39;y_L&#39;])]),dict_material,dict_sample)
    dict_sample[&#39;L_g&#39;] = [g1,g2]
    #Check if there is an overlap between those grains
    Grain.Compute_overlap_2_grains(dict_sample)
    self.assertTrue(dict_sample[&#39;overlap&#39;]==10,&#39;The overlap between two grains in contact is not well computed!&#39;)
    #Create two grain
    g1 = Grain.Grain(0,10,np.array([np.mean(dict_sample[&#39;x_L&#39;])-11,np.mean(dict_sample[&#39;y_L&#39;])]),dict_material,dict_sample)
    g2 = Grain.Grain(0,10,np.array([np.mean(dict_sample[&#39;x_L&#39;])+11,np.mean(dict_sample[&#39;y_L&#39;])]),dict_material,dict_sample)
    dict_sample[&#39;L_g&#39;] = [g1,g2]
    #Check if there is not an overlap between those grains
    Grain.Compute_overlap_2_grains(dict_sample)
    self.assertTrue(dict_sample[&#39;overlap&#39;]==-2,&#39;The overlap between two grains not in contact is not well computed!&#39;)</code></pre>
</details>
</dd>
<dt id="test.TestGrain.test_P_is_inside"><code class="name flex">
<span>def <span class="ident">test_P_is_inside</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to determine if a point is inside a grain geometry with Grain.P_is_inside().</p>
<p>Two cases are considered : the point is inside, the point is outside.</p>
<pre><code>Output :
    The result depends on the fact if points are well located or not (a bool)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_P_is_inside(self):
    &#39;&#39;&#39;
    Try to determine if a point is inside a grain geometry with Grain.P_is_inside().

    Two cases are considered : the point is inside, the point is outside.

        Output :
            The result depends on the fact if points are well located or not (a bool)
    &#39;&#39;&#39;
    #Acquire data
    dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
    #Create one grain
    grain = Grain.Grain(0,10,np.array([np.mean(dict_sample[&#39;x_L&#39;]),np.mean(dict_sample[&#39;y_L&#39;])]),dict_material,dict_sample)
    #check if the function works well in different configurations
    self.assertFalse(grain.P_is_inside(np.array([np.mean(dict_sample[&#39;x_L&#39;])+11,np.mean(dict_sample[&#39;y_L&#39;])])),&#39;An outside point is detected as inside by Grain.P_is_inside()...&#39;)
    self.assertTrue(grain.P_is_inside(np.array([np.mean(dict_sample[&#39;x_L&#39;]),np.mean(dict_sample[&#39;y_L&#39;])+1])),&#39;An inside point is detected as outside by Grain.P_is_inside()...&#39;)</code></pre>
</details>
</dd>
<dt id="test.TestGrain.test_geometric_study"><code class="name flex">
<span>def <span class="ident">test_geometric_study</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to study the grain geometry with Grain.geometric_study().</p>
<p>As Monte Carlo is used, some noise can occur. It is advised to test multiple times.</p>
<pre><code>Output :
    The result depends on the fact if the center is well located or not (a bool)
    The result depends on the fact if the surface is well assumed or not (a bool)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_geometric_study(self):
    &#39;&#39;&#39;
    Try to study the grain geometry with Grain.geometric_study().

    As Monte Carlo is used, some noise can occur. It is advised to test multiple times.

        Output :
            The result depends on the fact if the center is well located or not (a bool)
            The result depends on the fact if the surface is well assumed or not (a bool)
    &#39;&#39;&#39;
    #Acquire data
    dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
    #Create one grain
    grain = Grain.Grain(0,10,np.array([np.mean(dict_sample[&#39;x_L&#39;]),np.mean(dict_sample[&#39;y_L&#39;])]),dict_material,dict_sample)
    #try to do the geometric study of the grain
    grain.geometric_study(dict_sample)
    #define margine of the surface and the center (the study is done with a Monte Carlo method, some noise can be introduced)
    margin_center = 0.03*10 #10 is the radius see line upper
    margin_surface = 0.03*math.pi*10**2 #10 is the radius see line upper
    #check if the center computed is near the analytical one
    self.assertTrue(np.linalg.norm(np.array([np.mean(dict_sample[&#39;x_L&#39;]),np.mean(dict_sample[&#39;y_L&#39;])])-grain.center)&lt;margin_center,&#39;The estimation of the center position seems false (because of the Monte Carlo Method try to rerun or increase the margin)...&#39;)
    #check if the surface computed is near the analytical one
    self.assertTrue(abs(math.pi*10**2-grain.surface)&lt;margin_surface,&#39;The estimation of the surface seems false (because of the Monte Carlo Method try to rerun or increase the margin)...&#39;)</code></pre>
</details>
</dd>
<dt id="test.TestGrain.test_move_grain_interpolation"><code class="name flex">
<span>def <span class="ident">test_move_grain_interpolation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to move a grain by interpolation with Grain.move_grain_interpolation().</p>
<p>As Monte Carlo is used, some noise can occur. It is advised to test multiple times.</p>
<pre><code>Output :
    The result depends on the fact if the grain is well moved or not (a bool)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_move_grain_interpolation(self):
    &#39;&#39;&#39;
    Try to move a grain by interpolation with Grain.move_grain_interpolation().

    As Monte Carlo is used, some noise can occur. It is advised to test multiple times.

        Output :
            The result depends on the fact if the grain is well moved or not (a bool)
    &#39;&#39;&#39;
    #Acquire data
    dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
    #Create one grain
    grain = Grain.Grain(0,10,np.array([np.mean(dict_sample[&#39;x_L&#39;]),np.mean(dict_sample[&#39;y_L&#39;])]),dict_material,dict_sample)
    #try to move the grain
    grain.move_grain_interpolation(np.array([5,0]),dict_sample)
    #check if the center computed is near the analytical one
    self.assertTrue(np.linalg.norm(np.array([np.mean(dict_sample[&#39;x_L&#39;])+5,np.mean(dict_sample[&#39;y_L&#39;])])-grain.center)==0,&#39;The grain has not been well moved!&#39;)
    #Study the geometric of the grain
    grain.geometric_study(dict_sample)
    #define margine of the new center (the study is done with a Monte Carlo method, some noise can be introduced)
    margin_center = 0.03*10 #10 is the radius see line upper
    #check if the center computed is near the analytical one
    self.assertTrue(np.linalg.norm(np.array([np.mean(dict_sample[&#39;x_L&#39;])+5,np.mean(dict_sample[&#39;y_L&#39;])])-grain.center)&lt;margin_center,&#39;The displacement of the grain seems false after the etai_M rebuild (because of the Monte Carlo Method try to rerun or increase the margin)...&#39;)</code></pre>
</details>
</dd>
<dt id="test.TestGrain.test_move_grain_rebuild"><code class="name flex">
<span>def <span class="ident">test_move_grain_rebuild</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to move a grain by deconstruction and rebuild with Grain.move_grain_rebuild().</p>
<p>As Monte Carlo is used, some noise can occur. It is advised to test multiple times.</p>
<pre><code>Output :
    The result depends on the fact if the grain is well moved or not (a bool)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_move_grain_rebuild(self):
    &#39;&#39;&#39;
    Try to move a grain by deconstruction and rebuild with Grain.move_grain_rebuild().

    As Monte Carlo is used, some noise can occur. It is advised to test multiple times.

        Output :
            The result depends on the fact if the grain is well moved or not (a bool)
    &#39;&#39;&#39;
    #Acquire data
    dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
    #Create one grain
    grain = Grain.Grain(0,10,np.array([np.mean(dict_sample[&#39;x_L&#39;]),np.mean(dict_sample[&#39;y_L&#39;])]),dict_material,dict_sample)
    #try to move the grain
    grain.move_grain_rebuild(np.array([5,0]),dict_material,dict_sample)
    #check if the center computed is near the analytical one
    self.assertTrue(np.linalg.norm(np.array([np.mean(dict_sample[&#39;x_L&#39;])+5,np.mean(dict_sample[&#39;y_L&#39;])])-grain.center)==0,&#39;The grain has not been well moved!&#39;)
    #Study the geometric of the grain
    grain.geometric_study(dict_sample)
    #define margine of the new center (the study is done with a Monte Carlo method, some noise can be introduced)
    margin_center = 0.03*10 #10 is the radius see line upper
    #check if the center computed is near the analytical one
    self.assertTrue(np.linalg.norm(np.array([np.mean(dict_sample[&#39;x_L&#39;])+5,np.mean(dict_sample[&#39;y_L&#39;])])-grain.center)&lt;margin_center,&#39;The displacement of the grain seems false after the etai_M rebuild (because of the Monte Carlo Method try to rerun or increase the margin)...&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="test.TestOwntools"><code class="flex name class">
<span>class <span class="ident">TestOwntools</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<div class="desc"><p>Test functions from Owntools.py.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TestOwntools(unittest.TestCase):
    &#39;&#39;&#39;Test functions from Owntools.py.&#39;&#39;&#39;
    def test_is_PF_ACS_base_here(self):
        &#39;&#39;&#39;
        Verify if the template PF_ACS_base.i is in the directory.

        This file is used to generated MOOSE simulation input file.

            Output :
                The result depends on the fact if the file is here or not (a bool)
        &#39;&#39;&#39;
        #Check if the file PF_ACS_base.i is in the directory
        self.assertTrue(Path(&#39;PF_ACS_base.i&#39;).is_file(),&#34;The file PF_CH_AC_base.i should exists!&#34;)

    #---------------------------------------------------------------------------

    def test_Write_i(self):
        &#39;&#39;&#39;
        Try to create a MOOSE simulation input file with Owntools.Write.Write_i().

        This file is created from the template PF_ACS_base.i.

            Output :
                The result depends on the fact if the file is well created or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        dict_algorithm[&#39;i_PFDEM&#39;] = 0
        #try to create a .i file
        Owntools.Write.Write_i(dict_algorithm, dict_material, dict_sample, dict_sollicitation)
        #Check if the file PF_CH_AC_base.i is in the directory
        self.assertTrue(Path(dict_algorithm[&#39;namefile&#39;]+&#39;_&#39;+str(dict_algorithm[&#39;i_PFDEM&#39;])+&#39;.i&#39;).is_file(),&#34;The file namefile.i has not been created!&#34;)
        os.remove(dict_algorithm[&#39;namefile&#39;]+&#39;_&#39;+str(dict_algorithm[&#39;i_PFDEM&#39;])+&#39;.i&#39;)

    #---------------------------------------------------------------------------

    def test_index_to_str(self):
        &#39;&#39;&#39;
        Try to convert an integer into a string with Owntools.index_to_str().

        The string is composed by three elements.

            Output :
                The result depends on the fact if the conversions are well done or not (a bool)
        &#39;&#39;&#39;
        #check if the function works well in different configurations
        self.assertTrue(Owntools.index_to_str(7)==&#39;007&#39;,&#39;The conversion index_to_str() seems to do not for 00x...&#39;)
        self.assertTrue(Owntools.index_to_str(26)==&#39;026&#39;,&#39;The conversion index_to_str() seems to do not for 0xx...&#39;)
        self.assertTrue(Owntools.index_to_str(666)==&#39;666&#39;,&#39;The conversion index_to_str() seems to do not for xxx...&#39;)

    #---------------------------------------------------------------------------

    def test_Plot_config(self):
        &#39;&#39;&#39;
        Try to plot a sample configuration with Owntools.Plot_config().

            Output :
                The result depends on the fact if the .png file is well created or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        #create the two grains
        User.Add_2grains(dict_material,dict_sample)
        #create the solute
        User.Add_solute(dict_sample)
        #create a folder
        if Path(&#39;Debug&#39;).exists():
            shutil.rmtree(&#39;Debug&#39;)
        os.mkdir(&#39;Debug&#39;)
        os.mkdir(&#39;Debug/Configuration&#39;)
        #try to plot the configuration
        Owntools.Plot.Plot_config(dict_algorithm, dict_sample)
        #check if the .png has been created
        self.assertTrue(Path(&#39;Debug/Configuration/Configuration_0.png&#39;).is_file(),&#34;The image Debug/Configuration/Configuration_0.png has not been created by the function Owntools.Plot_config()!&#34;)
        shutil.rmtree(&#39;Debug&#39;)

    #---------------------------------------------------------------------------

    def test_Cosine_Profile(self):
        &#39;&#39;&#39;
        Try to compute a phase variable with Owntools.Cosine_Profile().

        Three cases are considered : inside the grain, at the interface, outside the grain.

            Output :
                The result depends on the fact if the phase variable is well computed or not (a bool)
        &#39;&#39;&#39;
        #check if the function works well in different configurations
        self.assertTrue(Owntools.Cosine_Profile(1,0,0.5)==1,&#39;The Owntools.Cosine_Profile() seems to do not for a point inside the grain...&#39;)
        self.assertTrue(Owntools.Cosine_Profile(1,1,0.5)==0.5*(1 + math.cos(math.pi/2)),&#39;The Owntools.Cosine_Profile() seems to do not for a point inside the interface...&#39;)
        self.assertTrue(Owntools.Cosine_Profile(1,2,0.5)==0,&#39;The Owntools.Cosine_Profile() seems to do not for a point outside the grain...&#39;)

    #---------------------------------------------------------------------------

    def test_Write_eta_txt(self):
        &#39;&#39;&#39;
        Try to create file needed for MOOSE simulation with Owntools.Write_eta_txt().

        This file is about etai variables.
        A sample with two grains is assumed.

            Output :
                The result depends on the fact if the file is well created or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        dict_algorithm[&#39;i_PFDEM&#39;] = 0
        #create the two grains
        User.Add_2grains(dict_material,dict_sample)
        #create a folder
        if Path(&#39;Data&#39;).exists():
            shutil.rmtree(&#39;Data&#39;)
        os.mkdir(&#39;Data&#39;)
        #try to create .txt files
        Owntools.Write.Write_eta_txt(dict_algorithm, dict_sample)
        #Check if the files are in the directory
        self.assertTrue(Path(&#39;Data/eta1_0.txt&#39;).is_file(),&#34;The file Data/eta1_0.txt has not been created!&#34;)
        self.assertTrue(Path(&#39;Data/eta2_0.txt&#39;).is_file(),&#34;The file Data/eta2_0.txt has not been created!&#34;)
        shutil.rmtree(&#39;Data&#39;)

    #---------------------------------------------------------------------------

    def test_Write_solute_txt(self):
        &#39;&#39;&#39;
        Try to create file needed for MOOSE simulation with Owntools.Write_solute_txt().

        This file is about c variable.

            Output :
                The result depends on the fact if the file is well created or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        dict_algorithm[&#39;i_PFDEM&#39;] = 0
        #create the two grains
        User.Add_solute(dict_sample)
        #create a folder
        if Path(&#39;Data&#39;).exists():
            shutil.rmtree(&#39;Data&#39;)
        os.mkdir(&#39;Data&#39;)
        #try to create .txt files
        Owntools.Write.Write_solute_txt(dict_algorithm, dict_sample)
        #Check if the files are in the directory
        self.assertTrue(Path(&#39;Data/c_0.txt&#39;).is_file(),&#34;The file Data/c_0.txt has not been created!&#34;)
        shutil.rmtree(&#39;Data&#39;)

    #---------------------------------------------------------------------------

    def test_Write_Emec_txt(self):
        &#39;&#39;&#39;
        Try to create file needed for MOOSE simulation with Owntools.Write_Emec_txt().

        This file is about the dissolution field due to mechanical loading.

            Output :
                The result depends on the fact if the file is well created or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        dict_algorithm[&#39;i_PFDEM&#39;] = 0
        #create the two grains
        User.Add_2grains(dict_material,dict_sample)
        #create a folder
        if Path(&#39;Data&#39;).exists():
            shutil.rmtree(&#39;Data&#39;)
        os.mkdir(&#39;Data&#39;)
        #try to create .txt files
        Owntools.Write.Write_Emec_txt(dict_algorithm, dict_sample)
        #Check if the files are in the directory
        self.assertTrue(Path(&#39;Data/ep_0.txt&#39;).is_file(),&#34;The file Data/ep_0.txt has not been created!&#34;)
        shutil.rmtree(&#39;Data&#39;)

    #---------------------------------------------------------------------------

    def test_Write_kc_txt(self):
        &#39;&#39;&#39;
        Try to create file needed for MOOSE simulation with Owntools.Write_kc_txt().

        This file is about the diffusion of the solute.

            Output :
                The result depends on the fact if the file is well created or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        dict_algorithm[&#39;i_PFDEM&#39;] = 0
        #create the two grains
        User.Add_2grains(dict_material,dict_sample)
        #create a folder
        if Path(&#39;Data&#39;).exists():
            shutil.rmtree(&#39;Data&#39;)
        os.mkdir(&#39;Data&#39;)
        #Compute the diffusion coefficient
        Owntools.Compute.Compute_kc_dil(dict_algorithm, dict_material,dict_sample)
        #try to create .txt files
        Owntools.Write.Write_kc_txt(dict_algorithm, dict_sample)
        #Check if the files are in the directory
        self.assertTrue(Path(&#39;Data/kc_0.txt&#39;).is_file(),&#34;The file Data/kc_0.txt has not been created!&#34;)
        shutil.rmtree(&#39;Data&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="test.TestOwntools.test_Cosine_Profile"><code class="name flex">
<span>def <span class="ident">test_Cosine_Profile</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to compute a phase variable with Owntools.Cosine_Profile().</p>
<p>Three cases are considered : inside the grain, at the interface, outside the grain.</p>
<pre><code>Output :
    The result depends on the fact if the phase variable is well computed or not (a bool)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_Cosine_Profile(self):
    &#39;&#39;&#39;
    Try to compute a phase variable with Owntools.Cosine_Profile().

    Three cases are considered : inside the grain, at the interface, outside the grain.

        Output :
            The result depends on the fact if the phase variable is well computed or not (a bool)
    &#39;&#39;&#39;
    #check if the function works well in different configurations
    self.assertTrue(Owntools.Cosine_Profile(1,0,0.5)==1,&#39;The Owntools.Cosine_Profile() seems to do not for a point inside the grain...&#39;)
    self.assertTrue(Owntools.Cosine_Profile(1,1,0.5)==0.5*(1 + math.cos(math.pi/2)),&#39;The Owntools.Cosine_Profile() seems to do not for a point inside the interface...&#39;)
    self.assertTrue(Owntools.Cosine_Profile(1,2,0.5)==0,&#39;The Owntools.Cosine_Profile() seems to do not for a point outside the grain...&#39;)</code></pre>
</details>
</dd>
<dt id="test.TestOwntools.test_Plot_config"><code class="name flex">
<span>def <span class="ident">test_Plot_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to plot a sample configuration with Owntools.Plot_config().</p>
<pre><code>Output :
    The result depends on the fact if the .png file is well created or not (a bool)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_Plot_config(self):
    &#39;&#39;&#39;
    Try to plot a sample configuration with Owntools.Plot_config().

        Output :
            The result depends on the fact if the .png file is well created or not (a bool)
    &#39;&#39;&#39;
    #Acquire data
    dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
    #create the two grains
    User.Add_2grains(dict_material,dict_sample)
    #create the solute
    User.Add_solute(dict_sample)
    #create a folder
    if Path(&#39;Debug&#39;).exists():
        shutil.rmtree(&#39;Debug&#39;)
    os.mkdir(&#39;Debug&#39;)
    os.mkdir(&#39;Debug/Configuration&#39;)
    #try to plot the configuration
    Owntools.Plot.Plot_config(dict_algorithm, dict_sample)
    #check if the .png has been created
    self.assertTrue(Path(&#39;Debug/Configuration/Configuration_0.png&#39;).is_file(),&#34;The image Debug/Configuration/Configuration_0.png has not been created by the function Owntools.Plot_config()!&#34;)
    shutil.rmtree(&#39;Debug&#39;)</code></pre>
</details>
</dd>
<dt id="test.TestOwntools.test_Write_Emec_txt"><code class="name flex">
<span>def <span class="ident">test_Write_Emec_txt</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to create file needed for MOOSE simulation with Owntools.Write_Emec_txt().</p>
<p>This file is about the dissolution field due to mechanical loading.</p>
<pre><code>Output :
    The result depends on the fact if the file is well created or not (a bool)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_Write_Emec_txt(self):
    &#39;&#39;&#39;
    Try to create file needed for MOOSE simulation with Owntools.Write_Emec_txt().

    This file is about the dissolution field due to mechanical loading.

        Output :
            The result depends on the fact if the file is well created or not (a bool)
    &#39;&#39;&#39;
    #Acquire data
    dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
    dict_algorithm[&#39;i_PFDEM&#39;] = 0
    #create the two grains
    User.Add_2grains(dict_material,dict_sample)
    #create a folder
    if Path(&#39;Data&#39;).exists():
        shutil.rmtree(&#39;Data&#39;)
    os.mkdir(&#39;Data&#39;)
    #try to create .txt files
    Owntools.Write.Write_Emec_txt(dict_algorithm, dict_sample)
    #Check if the files are in the directory
    self.assertTrue(Path(&#39;Data/ep_0.txt&#39;).is_file(),&#34;The file Data/ep_0.txt has not been created!&#34;)
    shutil.rmtree(&#39;Data&#39;)</code></pre>
</details>
</dd>
<dt id="test.TestOwntools.test_Write_eta_txt"><code class="name flex">
<span>def <span class="ident">test_Write_eta_txt</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to create file needed for MOOSE simulation with Owntools.Write_eta_txt().</p>
<p>This file is about etai variables.
A sample with two grains is assumed.</p>
<pre><code>Output :
    The result depends on the fact if the file is well created or not (a bool)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_Write_eta_txt(self):
    &#39;&#39;&#39;
    Try to create file needed for MOOSE simulation with Owntools.Write_eta_txt().

    This file is about etai variables.
    A sample with two grains is assumed.

        Output :
            The result depends on the fact if the file is well created or not (a bool)
    &#39;&#39;&#39;
    #Acquire data
    dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
    dict_algorithm[&#39;i_PFDEM&#39;] = 0
    #create the two grains
    User.Add_2grains(dict_material,dict_sample)
    #create a folder
    if Path(&#39;Data&#39;).exists():
        shutil.rmtree(&#39;Data&#39;)
    os.mkdir(&#39;Data&#39;)
    #try to create .txt files
    Owntools.Write.Write_eta_txt(dict_algorithm, dict_sample)
    #Check if the files are in the directory
    self.assertTrue(Path(&#39;Data/eta1_0.txt&#39;).is_file(),&#34;The file Data/eta1_0.txt has not been created!&#34;)
    self.assertTrue(Path(&#39;Data/eta2_0.txt&#39;).is_file(),&#34;The file Data/eta2_0.txt has not been created!&#34;)
    shutil.rmtree(&#39;Data&#39;)</code></pre>
</details>
</dd>
<dt id="test.TestOwntools.test_Write_i"><code class="name flex">
<span>def <span class="ident">test_Write_i</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to create a MOOSE simulation input file with Owntools.Write.Write_i().</p>
<p>This file is created from the template PF_ACS_base.i.</p>
<pre><code>Output :
    The result depends on the fact if the file is well created or not (a bool)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_Write_i(self):
    &#39;&#39;&#39;
    Try to create a MOOSE simulation input file with Owntools.Write.Write_i().

    This file is created from the template PF_ACS_base.i.

        Output :
            The result depends on the fact if the file is well created or not (a bool)
    &#39;&#39;&#39;
    #Acquire data
    dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
    dict_algorithm[&#39;i_PFDEM&#39;] = 0
    #try to create a .i file
    Owntools.Write.Write_i(dict_algorithm, dict_material, dict_sample, dict_sollicitation)
    #Check if the file PF_CH_AC_base.i is in the directory
    self.assertTrue(Path(dict_algorithm[&#39;namefile&#39;]+&#39;_&#39;+str(dict_algorithm[&#39;i_PFDEM&#39;])+&#39;.i&#39;).is_file(),&#34;The file namefile.i has not been created!&#34;)
    os.remove(dict_algorithm[&#39;namefile&#39;]+&#39;_&#39;+str(dict_algorithm[&#39;i_PFDEM&#39;])+&#39;.i&#39;)</code></pre>
</details>
</dd>
<dt id="test.TestOwntools.test_Write_kc_txt"><code class="name flex">
<span>def <span class="ident">test_Write_kc_txt</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to create file needed for MOOSE simulation with Owntools.Write_kc_txt().</p>
<p>This file is about the diffusion of the solute.</p>
<pre><code>Output :
    The result depends on the fact if the file is well created or not (a bool)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_Write_kc_txt(self):
    &#39;&#39;&#39;
    Try to create file needed for MOOSE simulation with Owntools.Write_kc_txt().

    This file is about the diffusion of the solute.

        Output :
            The result depends on the fact if the file is well created or not (a bool)
    &#39;&#39;&#39;
    #Acquire data
    dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
    dict_algorithm[&#39;i_PFDEM&#39;] = 0
    #create the two grains
    User.Add_2grains(dict_material,dict_sample)
    #create a folder
    if Path(&#39;Data&#39;).exists():
        shutil.rmtree(&#39;Data&#39;)
    os.mkdir(&#39;Data&#39;)
    #Compute the diffusion coefficient
    Owntools.Compute.Compute_kc_dil(dict_algorithm, dict_material,dict_sample)
    #try to create .txt files
    Owntools.Write.Write_kc_txt(dict_algorithm, dict_sample)
    #Check if the files are in the directory
    self.assertTrue(Path(&#39;Data/kc_0.txt&#39;).is_file(),&#34;The file Data/kc_0.txt has not been created!&#34;)
    shutil.rmtree(&#39;Data&#39;)</code></pre>
</details>
</dd>
<dt id="test.TestOwntools.test_Write_solute_txt"><code class="name flex">
<span>def <span class="ident">test_Write_solute_txt</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to create file needed for MOOSE simulation with Owntools.Write_solute_txt().</p>
<p>This file is about c variable.</p>
<pre><code>Output :
    The result depends on the fact if the file is well created or not (a bool)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_Write_solute_txt(self):
    &#39;&#39;&#39;
    Try to create file needed for MOOSE simulation with Owntools.Write_solute_txt().

    This file is about c variable.

        Output :
            The result depends on the fact if the file is well created or not (a bool)
    &#39;&#39;&#39;
    #Acquire data
    dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
    dict_algorithm[&#39;i_PFDEM&#39;] = 0
    #create the two grains
    User.Add_solute(dict_sample)
    #create a folder
    if Path(&#39;Data&#39;).exists():
        shutil.rmtree(&#39;Data&#39;)
    os.mkdir(&#39;Data&#39;)
    #try to create .txt files
    Owntools.Write.Write_solute_txt(dict_algorithm, dict_sample)
    #Check if the files are in the directory
    self.assertTrue(Path(&#39;Data/c_0.txt&#39;).is_file(),&#34;The file Data/c_0.txt has not been created!&#34;)
    shutil.rmtree(&#39;Data&#39;)</code></pre>
</details>
</dd>
<dt id="test.TestOwntools.test_index_to_str"><code class="name flex">
<span>def <span class="ident">test_index_to_str</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to convert an integer into a string with Owntools.index_to_str().</p>
<p>The string is composed by three elements.</p>
<pre><code>Output :
    The result depends on the fact if the conversions are well done or not (a bool)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_index_to_str(self):
    &#39;&#39;&#39;
    Try to convert an integer into a string with Owntools.index_to_str().

    The string is composed by three elements.

        Output :
            The result depends on the fact if the conversions are well done or not (a bool)
    &#39;&#39;&#39;
    #check if the function works well in different configurations
    self.assertTrue(Owntools.index_to_str(7)==&#39;007&#39;,&#39;The conversion index_to_str() seems to do not for 00x...&#39;)
    self.assertTrue(Owntools.index_to_str(26)==&#39;026&#39;,&#39;The conversion index_to_str() seems to do not for 0xx...&#39;)
    self.assertTrue(Owntools.index_to_str(666)==&#39;666&#39;,&#39;The conversion index_to_str() seems to do not for xxx...&#39;)</code></pre>
</details>
</dd>
<dt id="test.TestOwntools.test_is_PF_ACS_base_here"><code class="name flex">
<span>def <span class="ident">test_is_PF_ACS_base_here</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Verify if the template PF_ACS_base.i is in the directory.</p>
<p>This file is used to generated MOOSE simulation input file.</p>
<pre><code>Output :
    The result depends on the fact if the file is here or not (a bool)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_is_PF_ACS_base_here(self):
    &#39;&#39;&#39;
    Verify if the template PF_ACS_base.i is in the directory.

    This file is used to generated MOOSE simulation input file.

        Output :
            The result depends on the fact if the file is here or not (a bool)
    &#39;&#39;&#39;
    #Check if the file PF_ACS_base.i is in the directory
    self.assertTrue(Path(&#39;PF_ACS_base.i&#39;).is_file(),&#34;The file PF_CH_AC_base.i should exists!&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="test.TestReport"><code class="flex name class">
<span>class <span class="ident">TestReport</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<div class="desc"><p>Test functions from Report.py.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TestReport(unittest.TestCase):
    &#39;&#39;&#39;Test functions from Report.py.&#39;&#39;&#39;
    def test_Report(self):
        &#39;&#39;&#39;
        Try to generate a report.txt file.

            Output :
                The result depends on the fact if the file is well generated or not (a bool)
        &#39;&#39;&#39;
        #try to create a report.txt file
        simulation_report = Report.Report(&#39;Report&#39;,datetime.now())
        #check if the .txt has been created
        self.assertTrue(Path(&#39;Report.txt&#39;).is_file(),&#34;The file Report.txt has not been created by the function Report.Report()!&#34;)
        os.remove(&#39;Report.txt&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="test.TestReport.test_Report"><code class="name flex">
<span>def <span class="ident">test_Report</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to generate a report.txt file.</p>
<pre><code>Output :
    The result depends on the fact if the file is well generated or not (a bool)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_Report(self):
    &#39;&#39;&#39;
    Try to generate a report.txt file.

        Output :
            The result depends on the fact if the file is well generated or not (a bool)
    &#39;&#39;&#39;
    #try to create a report.txt file
    simulation_report = Report.Report(&#39;Report&#39;,datetime.now())
    #check if the .txt has been created
    self.assertTrue(Path(&#39;Report.txt&#39;).is_file(),&#34;The file Report.txt has not been created by the function Report.Report()!&#34;)
    os.remove(&#39;Report.txt&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="test.TestUser"><code class="flex name class">
<span>class <span class="ident">TestUser</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<div class="desc"><p>Test functions from User.py.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TestUser(unittest.TestCase):
    &#39;&#39;&#39;Test functions from User.py.&#39;&#39;&#39;
    def test_All_parameters(self):
        &#39;&#39;&#39;
        Try to acquire data from the function User.All_parameters().

            Output :
                The result depends on the fact if data are well acquired or not (a bool)
        &#39;&#39;&#39;
        #try to acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        #check if all data are dictionnaries
        self.assertTrue((type(dict_algorithm) is dict) and (type(dict_material) is dict) and (type(dict_sample) is dict) and (type(dict_sollicitation) is dict),&#39;Outputs from User.All_parameters() are not dictionaries!&#39;)

    #---------------------------------------------------------------------------

    def test_Add_2grains(self):
        &#39;&#39;&#39;
        Try to generate two grains with the function User.Add_2grains().

            Output :
                The result depends on the fact if grains are well generated or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        #try to create 2 grains
        User.Add_2grains(dict_material,dict_sample)
        #check if there are 2 grains
        self.assertTrue(len(dict_sample[&#39;L_g&#39;])==2,&#39;The function User.Add_2grains does not create 2 grains!&#39;)

    #---------------------------------------------------------------------------

    def test_Add_solute(self):
        &#39;&#39;&#39;
        Try to generate a solute with the function User.Add_solute().

            Output :
                The result depends on the fact if solute is well generated or not (a bool)
        &#39;&#39;&#39;
        #Acquire data
        dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
        #try to create 2 grains
        User.Add_solute(dict_sample)
        #check if there are 2 grains
        self.assertTrue(&#39;solute_M&#39; in dict_sample.keys(),&#39;The function User.Add_solute does not create a solute!&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="test.TestUser.test_Add_2grains"><code class="name flex">
<span>def <span class="ident">test_Add_2grains</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to generate two grains with the function User.Add_2grains().</p>
<pre><code>Output :
    The result depends on the fact if grains are well generated or not (a bool)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_Add_2grains(self):
    &#39;&#39;&#39;
    Try to generate two grains with the function User.Add_2grains().

        Output :
            The result depends on the fact if grains are well generated or not (a bool)
    &#39;&#39;&#39;
    #Acquire data
    dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
    #try to create 2 grains
    User.Add_2grains(dict_material,dict_sample)
    #check if there are 2 grains
    self.assertTrue(len(dict_sample[&#39;L_g&#39;])==2,&#39;The function User.Add_2grains does not create 2 grains!&#39;)</code></pre>
</details>
</dd>
<dt id="test.TestUser.test_Add_solute"><code class="name flex">
<span>def <span class="ident">test_Add_solute</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to generate a solute with the function User.Add_solute().</p>
<pre><code>Output :
    The result depends on the fact if solute is well generated or not (a bool)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_Add_solute(self):
    &#39;&#39;&#39;
    Try to generate a solute with the function User.Add_solute().

        Output :
            The result depends on the fact if solute is well generated or not (a bool)
    &#39;&#39;&#39;
    #Acquire data
    dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
    #try to create 2 grains
    User.Add_solute(dict_sample)
    #check if there are 2 grains
    self.assertTrue(&#39;solute_M&#39; in dict_sample.keys(),&#39;The function User.Add_solute does not create a solute!&#39;)</code></pre>
</details>
</dd>
<dt id="test.TestUser.test_All_parameters"><code class="name flex">
<span>def <span class="ident">test_All_parameters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to acquire data from the function User.All_parameters().</p>
<pre><code>Output :
    The result depends on the fact if data are well acquired or not (a bool)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_All_parameters(self):
    &#39;&#39;&#39;
    Try to acquire data from the function User.All_parameters().

        Output :
            The result depends on the fact if data are well acquired or not (a bool)
    &#39;&#39;&#39;
    #try to acquire data
    dict_algorithm, dict_material, dict_sample, dict_sollicitation = User.All_parameters()
    #check if all data are dictionnaries
    self.assertTrue((type(dict_algorithm) is dict) and (type(dict_material) is dict) and (type(dict_sample) is dict) and (type(dict_sollicitation) is dict),&#39;Outputs from User.All_parameters() are not dictionaries!&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="test.TestExample" href="#test.TestExample">TestExample</a></code></h4>
<ul class="">
<li><code><a title="test.TestExample.test_example" href="#test.TestExample.test_example">test_example</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="test.TestGlobal" href="#test.TestGlobal">TestGlobal</a></code></h4>
<ul class="">
<li><code><a title="test.TestGlobal.test_all_files_here" href="#test.TestGlobal.test_all_files_here">test_all_files_here</a></code></li>
<li><code><a title="test.TestGlobal.test_main_iteration_main" href="#test.TestGlobal.test_main_iteration_main">test_main_iteration_main</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="test.TestGrain" href="#test.TestGrain">TestGrain</a></code></h4>
<ul class="">
<li><code><a title="test.TestGrain.test_Compute_overlap_2_grains" href="#test.TestGrain.test_Compute_overlap_2_grains">test_Compute_overlap_2_grains</a></code></li>
<li><code><a title="test.TestGrain.test_P_is_inside" href="#test.TestGrain.test_P_is_inside">test_P_is_inside</a></code></li>
<li><code><a title="test.TestGrain.test_geometric_study" href="#test.TestGrain.test_geometric_study">test_geometric_study</a></code></li>
<li><code><a title="test.TestGrain.test_move_grain_interpolation" href="#test.TestGrain.test_move_grain_interpolation">test_move_grain_interpolation</a></code></li>
<li><code><a title="test.TestGrain.test_move_grain_rebuild" href="#test.TestGrain.test_move_grain_rebuild">test_move_grain_rebuild</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="test.TestOwntools" href="#test.TestOwntools">TestOwntools</a></code></h4>
<ul class="">
<li><code><a title="test.TestOwntools.test_Cosine_Profile" href="#test.TestOwntools.test_Cosine_Profile">test_Cosine_Profile</a></code></li>
<li><code><a title="test.TestOwntools.test_Plot_config" href="#test.TestOwntools.test_Plot_config">test_Plot_config</a></code></li>
<li><code><a title="test.TestOwntools.test_Write_Emec_txt" href="#test.TestOwntools.test_Write_Emec_txt">test_Write_Emec_txt</a></code></li>
<li><code><a title="test.TestOwntools.test_Write_eta_txt" href="#test.TestOwntools.test_Write_eta_txt">test_Write_eta_txt</a></code></li>
<li><code><a title="test.TestOwntools.test_Write_i" href="#test.TestOwntools.test_Write_i">test_Write_i</a></code></li>
<li><code><a title="test.TestOwntools.test_Write_kc_txt" href="#test.TestOwntools.test_Write_kc_txt">test_Write_kc_txt</a></code></li>
<li><code><a title="test.TestOwntools.test_Write_solute_txt" href="#test.TestOwntools.test_Write_solute_txt">test_Write_solute_txt</a></code></li>
<li><code><a title="test.TestOwntools.test_index_to_str" href="#test.TestOwntools.test_index_to_str">test_index_to_str</a></code></li>
<li><code><a title="test.TestOwntools.test_is_PF_ACS_base_here" href="#test.TestOwntools.test_is_PF_ACS_base_here">test_is_PF_ACS_base_here</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="test.TestReport" href="#test.TestReport">TestReport</a></code></h4>
<ul class="">
<li><code><a title="test.TestReport.test_Report" href="#test.TestReport.test_Report">test_Report</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="test.TestUser" href="#test.TestUser">TestUser</a></code></h4>
<ul class="">
<li><code><a title="test.TestUser.test_Add_2grains" href="#test.TestUser.test_Add_2grains">test_Add_2grains</a></code></li>
<li><code><a title="test.TestUser.test_Add_solute" href="#test.TestUser.test_Add_solute">test_Add_solute</a></code></li>
<li><code><a title="test.TestUser.test_All_parameters" href="#test.TestUser.test_All_parameters">test_All_parameters</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
<br>
<a href="https://alexsacmorane.github.io/pfdem/pfdem_acs_mg">PFDEM_ACS_MG</a>
<br>
<a href="https://alexsacmorane.github.io/pfdem">PFDEM</a>
<br>
<a href="https://alexsacmorane.github.io">Home</a>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
